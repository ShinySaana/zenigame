/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const LIBSEVEN_VERSION_MAJOR: u32 = 0;
pub const LIBSEVEN_VERSION_MINOR: u32 = 17;
pub const LIBSEVEN_VERSION_PATCH: u32 = 0;
pub const BF_PSR_MODE_OFFSET: u32 = 0;
pub const BF_PSR_MODE_LENGTH: u32 = 5;
pub const BF_PSR_CONTROL_BITS_OFFSET: u32 = 0;
pub const BF_PSR_CONTROL_BITS_LENGTH: u32 = 8;
pub const BF_PSR_FLAGS_OFFSET: u32 = 28;
pub const BF_PSR_FLAGS_LENGHT: u32 = 4;
pub const BF_DMA_DST_OFFSET: u32 = 5;
pub const BF_DMA_DST_LENGTH: u32 = 2;
pub const BF_DMA_SRC_OFFSET: u32 = 7;
pub const BF_DMA_SRC_LENGTH: u32 = 2;
pub const BF_DMA_START_OFFSET: u32 = 12;
pub const BF_DMA_START_LENGTH: u32 = 2;
pub const BF_SIO_MODE_OFFSET: u32 = 12;
pub const BF_SIO_MODE_LENGTH: u32 = 2;
pub const BF_R_MODE_OFFSET: u32 = 14;
pub const BF_R_MODE_LENGTH: u32 = 2;
pub const BF_TIMER_FREQ_OFFSET: u32 = 0;
pub const BF_TIMER_FREQ_LENGTH: u32 = 3;
pub const BF_VIDEO_MODE_OFFSET: u32 = 0;
pub const BF_VIDEO_MODE_LENGTH: u32 = 3;
pub const BF_LCD_TARGET_VCOUNT_OFFSET: u32 = 8;
pub const BF_LCD_TARGET_VCOUNT_LENGTH: u32 = 8;
pub const BF_BG_PRIORITY_OFFSET: u32 = 0;
pub const BF_BG_PRIORITY_LENGTH: u32 = 2;
pub const BF_BG_GFX_BASE_OFFSET: u32 = 2;
pub const BF_BG_GFX_BASE_LENGTH: u32 = 2;
pub const BF_BG_MAP_BASE_OFFSET: u32 = 8;
pub const BF_BG_MAP_BASE_LENGTH: u32 = 5;
pub const BF_BG_SIZE_OFFSET: u32 = 14;
pub const BF_BG_SIZE_LENGTH: u32 = 2;
pub const BF_BG_AFFINE_SIZE_OFFSET: u32 = 14;
pub const BF_BG_AFFINE_SIZE_LENGTH: u32 = 2;
pub const BF_WAIT_SRAM_OFFSET: u32 = 0;
pub const BF_WAIT_SRAM_LENGTH: u32 = 2;
pub const BF_WAIT_ROM_N_OFFSET: u32 = 2;
pub const BF_WAIT_ROM_N_LENGTH: u32 = 2;
pub const BF_WAIT_ROM_S_OFFSET: u32 = 4;
pub const BF_WAIT_ROM_S_LENGTH: u32 = 1;
pub const BF_SPI_CLOCK_OFFSET: u32 = 0;
pub const BF_SPI_CLOCK_LENGTH: u32 = 2;
pub const BF_UART_BAUD_OFFSET: u32 = 0;
pub const BF_UART_BAUD_LENGTH: u32 = 2;
pub const MODE3_WIDTH: u32 = 240;
pub const MODE3_HEIGHT: u32 = 160;
pub const MODE4_WIDTH: u32 = 240;
pub const MODE4_HEIGHT: u32 = 160;
pub const MODE5_WIDTH: u32 = 160;
pub const MODE5_HEIGHT: u32 = 128;
pub const BF_TILE_NUMBER_OFFSET: u32 = 0;
pub const BF_TILE_NUMBER_LENGTH: u32 = 10;
pub const BF_TILE_PALETTE_OFFSET: u32 = 12;
pub const BF_TILE_PALETTE_LENGTH: u32 = 4;
pub const BF_BLEND_MODE_OFFSET: u32 = 6;
pub const BF_BLEND_MODE_LENGTH: u32 = 2;
pub const BF_COLOR_R_OFFSET: u32 = 0;
pub const BF_COLOR_R_LENGTH: u32 = 5;
pub const BF_COLOR_G_OFFSET: u32 = 5;
pub const BF_COLOR_G_LENGTH: u32 = 5;
pub const BF_COLOR_B_OFFSET: u32 = 10;
pub const BF_COLOR_B_LENGTH: u32 = 5;
pub const BF_MOSAIC_BG_H_OFFSET: u32 = 0;
pub const BF_MOSAIC_BG_H_LENGTH: u32 = 4;
pub const BF_MOSAIC_BG_V_OFFSET: u32 = 4;
pub const BF_MOSAIC_BG_V_LENGTH: u32 = 4;
pub const BF_MOSAIC_OBJ_H_OFFSET: u32 = 8;
pub const BF_MOSAIC_OBJ_H_LENGTH: u32 = 4;
pub const BF_MOSAIC_OBJ_V_OFFSET: u32 = 12;
pub const BF_MOSAIC_OBJ_V_LENGTH: u32 = 4;
pub const BF_OBJ_Y_POS_OFFSET: u32 = 0;
pub const BF_OBJ_Y_POS_LENGTH: u32 = 8;
pub const BF_OBJ_MODE_OFFSET: u32 = 8;
pub const BF_OBJ_MODE_LENGTH: u32 = 2;
pub const BF_OBJ_TYPE_OFFSET: u32 = 10;
pub const BF_OBJ_TYPE_LENGTH: u32 = 2;
pub const BF_OBJ_SHAPE_OFFSET: u32 = 14;
pub const BF_OBJ_SHAPE_LENGTH: u32 = 2;
pub const BF_OBJ_X_POS_OFFSET: u32 = 0;
pub const BF_OBJ_X_POS_LENGTH: u32 = 9;
pub const BF_OBJ_AFFINE_MATRIX_OFFSET: u32 = 9;
pub const BF_OBJ_AFFINE_MATRIX_LENGTH: u32 = 5;
pub const BF_OBJ_SIZE_OFFSET: u32 = 14;
pub const BF_OBJ_SIZE_LENGTH: u32 = 2;
pub const BF_OBJ_TILE_NUMBER_OFFSET: u32 = 0;
pub const BF_OBJ_TILE_NUMBER_LENGTH: u32 = 10;
pub const BF_OBJ_PRIORITY_OFFSET: u32 = 10;
pub const BF_OBJ_PRIORITY_LENGTH: u32 = 2;
pub const BF_OBJ_PALETTE_NUMBER_OFFSET: u32 = 12;
pub const BF_OBJ_PALETTE_NUMBER_LENGTH: u32 = 4;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub const SoftwareInterruptNumber_SWI_SOFTRESET: SoftwareInterruptNumber = 0;
pub const SoftwareInterruptNumber_SWI_REGISTERRAMRESET: SoftwareInterruptNumber = 1;
pub const SoftwareInterruptNumber_SWI_HALT: SoftwareInterruptNumber = 2;
pub const SoftwareInterruptNumber_SWI_STOP: SoftwareInterruptNumber = 3;
pub const SoftwareInterruptNumber_SWI_INTRWAIT: SoftwareInterruptNumber = 4;
pub const SoftwareInterruptNumber_SWI_VBLANKINTRWAIT: SoftwareInterruptNumber = 5;
pub const SoftwareInterruptNumber_SWI_DIV: SoftwareInterruptNumber = 6;
pub const SoftwareInterruptNumber_SWI_SQRT: SoftwareInterruptNumber = 8;
pub const SoftwareInterruptNumber_SWI_ARCTAN: SoftwareInterruptNumber = 9;
pub const SoftwareInterruptNumber_SWI_ARCTAN2: SoftwareInterruptNumber = 10;
pub const SoftwareInterruptNumber_SWI_CPUSET: SoftwareInterruptNumber = 11;
pub const SoftwareInterruptNumber_SWI_CPUFASTSET: SoftwareInterruptNumber = 12;
pub const SoftwareInterruptNumber_SWI_BIOSCHECKSUM: SoftwareInterruptNumber = 13;
pub const SoftwareInterruptNumber_SWI_BGAFFINESET: SoftwareInterruptNumber = 14;
pub const SoftwareInterruptNumber_SWI_OBJAFFINESET: SoftwareInterruptNumber = 15;
pub const SoftwareInterruptNumber_SWI_BITUNPACK: SoftwareInterruptNumber = 16;
pub const SoftwareInterruptNumber_SWI_LZ77UNCOMPWRAM: SoftwareInterruptNumber = 17;
pub const SoftwareInterruptNumber_SWI_LZ77UNCOMPVRAM: SoftwareInterruptNumber = 18;
pub const SoftwareInterruptNumber_SWI_HUFFUNCOMP: SoftwareInterruptNumber = 19;
pub const SoftwareInterruptNumber_SWI_RLUNCOMPWRAM: SoftwareInterruptNumber = 20;
pub const SoftwareInterruptNumber_SWI_RLUNCOMPVRAM: SoftwareInterruptNumber = 21;
pub const SoftwareInterruptNumber_SWI_DIFF8BITUNFILTERWRAM: SoftwareInterruptNumber = 22;
pub const SoftwareInterruptNumber_SWI_DIFF8BITUNFILTERVRAM: SoftwareInterruptNumber = 23;
pub const SoftwareInterruptNumber_SWI_DIFF16BITUNFILTER: SoftwareInterruptNumber = 24;
pub const SoftwareInterruptNumber_SWI_SOUNDBIAS: SoftwareInterruptNumber = 25;
pub const SoftwareInterruptNumber_SWI_SOUNDDRIVERINIT: SoftwareInterruptNumber = 26;
pub const SoftwareInterruptNumber_SWI_SOUNDDRIVERMODE: SoftwareInterruptNumber = 27;
pub const SoftwareInterruptNumber_SWI_SOUNDDRIVERMAIN: SoftwareInterruptNumber = 28;
pub const SoftwareInterruptNumber_SWI_SOUNDDRIVERVSYNC: SoftwareInterruptNumber = 29;
pub const SoftwareInterruptNumber_SWI_SOUNDCHANNELCLEAR: SoftwareInterruptNumber = 30;
pub const SoftwareInterruptNumber_SWI_MIDIKEY2FREQ: SoftwareInterruptNumber = 31;
pub const SoftwareInterruptNumber_SWI_MUSICPLAYEROPEN: SoftwareInterruptNumber = 32;
pub const SoftwareInterruptNumber_SWI_MUSICPLAYERSTART: SoftwareInterruptNumber = 33;
pub const SoftwareInterruptNumber_SWI_MUSICPLAYERSTOP: SoftwareInterruptNumber = 34;
pub const SoftwareInterruptNumber_SWI_MUSICPLAYERCONTINUE: SoftwareInterruptNumber = 35;
pub const SoftwareInterruptNumber_SWI_MUSICPLAYERFADEOUT: SoftwareInterruptNumber = 36;
pub const SoftwareInterruptNumber_SWI_MULTIBOOT: SoftwareInterruptNumber = 37;
pub const SoftwareInterruptNumber_SWI_HARDRESET: SoftwareInterruptNumber = 38;
pub const SoftwareInterruptNumber_SWI_SOUNDDRIVERVSYNCOFF: SoftwareInterruptNumber = 40;
pub const SoftwareInterruptNumber_SWI_SOUNDDRIVERVSYNCON: SoftwareInterruptNumber = 41;
pub type SoftwareInterruptNumber = ::core::ffi::c_uint;
pub const GpioDirection_GPIO_IN: GpioDirection = 0;
pub const GpioDirection_GPIO_OUT: GpioDirection = 1;
pub type GpioDirection = ::core::ffi::c_uint;
pub const GpioControl_GPIO_WRITEONLY: GpioControl = 0;
pub const GpioControl_GPIO_READWRITE: GpioControl = 1;
pub type GpioControl = ::core::ffi::c_uint;
pub const ProgramStatusRegister_PSR_MODE_USR: ProgramStatusRegister = 16;
pub const ProgramStatusRegister_PSR_MODE_FIQ: ProgramStatusRegister = 17;
pub const ProgramStatusRegister_PSR_MODE_IRQ: ProgramStatusRegister = 18;
pub const ProgramStatusRegister_PSR_MODE_SVC: ProgramStatusRegister = 19;
pub const ProgramStatusRegister_PSR_MODE_ABT: ProgramStatusRegister = 23;
pub const ProgramStatusRegister_PSR_MODE_UND: ProgramStatusRegister = 27;
pub const ProgramStatusRegister_PSR_MODE_SYS: ProgramStatusRegister = 31;
pub const ProgramStatusRegister_PSR_STATE_THUMB: ProgramStatusRegister = 32;
pub const ProgramStatusRegister_PSR_FIQ_DISABLE: ProgramStatusRegister = 64;
pub const ProgramStatusRegister_PSR_IRQ_DISABLE: ProgramStatusRegister = 128;
pub const ProgramStatusRegister_PSR_FLAG_V: ProgramStatusRegister = 268435456;
pub const ProgramStatusRegister_PSR_FLAG_C: ProgramStatusRegister = 536870912;
pub const ProgramStatusRegister_PSR_FLAG_Z: ProgramStatusRegister = 1073741824;
pub const ProgramStatusRegister_PSR_FLAG_N: ProgramStatusRegister = -2147483648;
pub type ProgramStatusRegister = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA {
    pub src: *const ::core::ffi::c_void,
    pub dst: *mut ::core::ffi::c_void,
    pub len: u16,
    pub cnt: u16,
}
#[test]
fn bindgen_test_layout_DMA() {
    const UNINIT: ::core::mem::MaybeUninit<DMA> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA>(),
        12usize,
        concat!("Size of: ", stringify!(DMA))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(src))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(dst))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        10usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(cnt))
    );
}
pub const DMAControl_DMA_DST_INCREMENT: DMAControl = 0;
pub const DMAControl_DMA_DST_DECREMENT: DMAControl = 32;
pub const DMAControl_DMA_DST_FIXED: DMAControl = 64;
pub const DMAControl_DMA_DST_RELOAD: DMAControl = 96;
pub const DMAControl_DMA_SRC_INCREMENT: DMAControl = 0;
pub const DMAControl_DMA_SRC_DECREMENT: DMAControl = 128;
pub const DMAControl_DMA_SRC_FIXED: DMAControl = 256;
pub const DMAControl_DMA_REPEAT: DMAControl = 512;
pub const DMAControl_DMA_32BIT: DMAControl = 1024;
pub const DMAControl_DMA_16BIT: DMAControl = 0;
pub const DMAControl_DMA_START_NOW: DMAControl = 0;
pub const DMAControl_DMA_START_HBLANK: DMAControl = 4096;
pub const DMAControl_DMA_START_VBLANK: DMAControl = 8192;
pub const DMAControl_DMA_START_SOUND: DMAControl = 12288;
pub const DMAControl_DMA_START_CAPTURE: DMAControl = 12288;
pub const DMAControl_DMA_IRQ_ENABLE: DMAControl = 16384;
pub const DMAControl_DMA_ENABLE: DMAControl = 32768;
pub type DMAControl = ::core::ffi::c_uint;
pub const DMAControlPreset_DMA_PRESET_COPY16: DMAControlPreset = 0;
pub const DMAControlPreset_DMA_PRESET_COPY32: DMAControlPreset = 1024;
pub const DMAControlPreset_DMA_PRESET_FILL16: DMAControlPreset = 256;
pub const DMAControlPreset_DMA_PRESET_FILL32: DMAControlPreset = 1280;
pub const DMAControlPreset_DMA_PRESET_HBLANK: DMAControlPreset = 4608;
pub const DMAControlPreset_DMA_PRESET_VBLANK: DMAControlPreset = 8704;
pub const DMAControlPreset_DMA_PRESET_SOUND: DMAControlPreset = 12800;
pub const DMAControlPreset_DMA_PRESET_CAPTURE: DMAControlPreset = 12800;
pub type DMAControlPreset = ::core::ffi::c_uint;
extern "C" {
    pub fn dmaSet(channel: u32, dma: DMA);
}
pub const Key_KEY_A: Key = 1;
pub const Key_KEY_B: Key = 2;
pub const Key_KEY_SELECT: Key = 4;
pub const Key_KEY_START: Key = 8;
pub const Key_KEY_RIGHT: Key = 16;
pub const Key_KEY_LEFT: Key = 32;
pub const Key_KEY_UP: Key = 64;
pub const Key_KEY_DOWN: Key = 128;
pub const Key_KEY_R: Key = 256;
pub const Key_KEY_L: Key = 512;
pub type Key = ::core::ffi::c_uint;
pub const KeyGroup_KEYS_DPAD_X: KeyGroup = 48;
pub const KeyGroup_KEYS_DPAD_Y: KeyGroup = 192;
pub const KeyGroup_KEYS_DPAD: KeyGroup = 240;
pub const KeyGroup_KEYS_AB: KeyGroup = 3;
pub const KeyGroup_KEYS_LR: KeyGroup = 768;
pub const KeyGroup_KEYS_STARTSELECT: KeyGroup = 12;
pub const KeyGroup_KEYS_BUTTONS: KeyGroup = 783;
pub const KeyGroup_KEYS_ALL: KeyGroup = 1023;
pub type KeyGroup = ::core::ffi::c_uint;
pub const KeyIndex_KEY_INDEX_A: KeyIndex = 0;
pub const KeyIndex_KEY_INDEX_B: KeyIndex = 1;
pub const KeyIndex_KEY_INDEX_SELECT: KeyIndex = 2;
pub const KeyIndex_KEY_INDEX_START: KeyIndex = 3;
pub const KeyIndex_KEY_INDEX_RIGHT: KeyIndex = 4;
pub const KeyIndex_KEY_INDEX_LEFT: KeyIndex = 5;
pub const KeyIndex_KEY_INDEX_UP: KeyIndex = 6;
pub const KeyIndex_KEY_INDEX_DOWN: KeyIndex = 7;
pub const KeyIndex_KEY_INDEX_R: KeyIndex = 8;
pub const KeyIndex_KEY_INDEX_L: KeyIndex = 9;
pub const KeyIndex_KEY_INDEX_MAX: KeyIndex = 10;
pub type KeyIndex = ::core::ffi::c_uint;
pub const KeyIRQ_KEY_IRQ_ENABLE: KeyIRQ = 16384;
pub const KeyIRQ_KEY_IRQ_PRESS_ALL: KeyIRQ = 32768;
pub const KeyIRQ_KEY_IRQ_PRESS_ANY: KeyIRQ = 0;
pub type KeyIRQ = ::core::ffi::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct InputState {
    pub now: u16,
    pub last: u16,
}
#[test]
fn bindgen_test_layout_InputState() {
    const UNINIT: ::core::mem::MaybeUninit<InputState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputState>(),
        4usize,
        concat!("Size of: ", stringify!(InputState))
    );
    assert_eq!(
        ::core::mem::align_of::<InputState>(),
        4usize,
        concat!("Alignment of ", stringify!(InputState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).now) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputState),
            "::",
            stringify!(now)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(InputState),
            "::",
            stringify!(last)
        )
    );
}
extern "C" {
    pub fn inputNew() -> InputState;
}
extern "C" {
    pub fn inputPoll(i: InputState) -> InputState;
}
extern "C" {
    pub fn inputKeysPressed(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputKeysReleased(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputKeysDown(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputKeysUp(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputAxisX(i: InputState) -> i32;
}
extern "C" {
    pub fn inputAxisY(i: InputState) -> i32;
}
extern "C" {
    pub fn inputAxisLR(i: InputState) -> i32;
}
extern "C" {
    pub fn inputAxisAB(i: InputState) -> i32;
}
pub const IRQ_IRQ_VBLANK: IRQ = 1;
pub const IRQ_IRQ_HBLANK: IRQ = 2;
pub const IRQ_IRQ_VCOUNT: IRQ = 4;
pub const IRQ_IRQ_TIMER_0: IRQ = 8;
pub const IRQ_IRQ_TIMER_1: IRQ = 16;
pub const IRQ_IRQ_TIMER_2: IRQ = 32;
pub const IRQ_IRQ_TIMER_3: IRQ = 64;
pub const IRQ_IRQ_SERIAL: IRQ = 128;
pub const IRQ_IRQ_DMA_0: IRQ = 256;
pub const IRQ_IRQ_DMA_1: IRQ = 512;
pub const IRQ_IRQ_DMA_2: IRQ = 1024;
pub const IRQ_IRQ_DMA_3: IRQ = 2048;
pub const IRQ_IRQ_KEYPAD: IRQ = 4096;
pub const IRQ_IRQ_CARTRIDGE: IRQ = 8192;
pub type IRQ = ::core::ffi::c_uint;
pub const IRQGroup_IRQS_BLANK: IRQGroup = 3;
pub const IRQGroup_IRQS_TIMER: IRQGroup = 120;
pub const IRQGroup_IRQS_DMA: IRQGroup = 3840;
pub const IRQGroup_IRQS_EXTERNAL: IRQGroup = 12416;
pub const IRQGroup_IRQS_ALL: IRQGroup = 16383;
pub type IRQGroup = ::core::ffi::c_uint;
pub const IRQIndex_IRQ_INDEX_VBLANK: IRQIndex = 0;
pub const IRQIndex_IRQ_INDEX_HBLANK: IRQIndex = 1;
pub const IRQIndex_IRQ_INDEX_VCOUNT: IRQIndex = 2;
pub const IRQIndex_IRQ_INDEX_TIMER_0: IRQIndex = 3;
pub const IRQIndex_IRQ_INDEX_TIMER_1: IRQIndex = 4;
pub const IRQIndex_IRQ_INDEX_TIMER_2: IRQIndex = 5;
pub const IRQIndex_IRQ_INDEX_TIMER_3: IRQIndex = 6;
pub const IRQIndex_IRQ_INDEX_SERIAL: IRQIndex = 7;
pub const IRQIndex_IRQ_INDEX_DMA_0: IRQIndex = 8;
pub const IRQIndex_IRQ_INDEX_DMA_1: IRQIndex = 9;
pub const IRQIndex_IRQ_INDEX_DMA_2: IRQIndex = 10;
pub const IRQIndex_IRQ_INDEX_DMA_3: IRQIndex = 11;
pub const IRQIndex_IRQ_INDEX_KEYPAD: IRQIndex = 12;
pub const IRQIndex_IRQ_INDEX_CARTRIDGE: IRQIndex = 13;
pub const IRQIndex_IRQ_INDEX_MAX: IRQIndex = 14;
pub type IRQIndex = ::core::ffi::c_uint;
pub type IsrFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type IrqHandlerFn = ::core::option::Option<unsafe extern "C" fn(arg1: u16)>;
extern "C" {
    pub fn irqInit(isr: IsrFn);
}
extern "C" {
    pub fn irqInitDefault();
}
extern "C" {
    pub fn irqInitSimple(fn_: IrqHandlerFn);
}
extern "C" {
    pub fn irqInitStub();
}
extern "C" {
    pub fn irqHandlerSet(irq: u16, fn_: IrqHandlerFn) -> bool;
}
extern "C" {
    pub fn irqHandlerGet(irq: u16, fn_: *mut IrqHandlerFn) -> bool;
}
extern "C" {
    pub fn irqHandlerSwap(arg1: u16, fn_: *mut IrqHandlerFn) -> bool;
}
extern "C" {
    pub fn irqEnable(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqDisable(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqEnableFull(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqDisableFull(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqFree(
        f: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
}
pub const SerialControl_SIO_MODE_SPI_8BIT: SerialControl = 0;
pub const SerialControl_SIO_MODE_SPI_32BIT: SerialControl = 4096;
pub const SerialControl_SIO_MODE_MULTI: SerialControl = 8192;
pub const SerialControl_SIO_MODE_UART: SerialControl = 12288;
pub const SerialControl_SIO_MODE_RAW: SerialControl = 0;
pub const SerialControl_SIO_MODE_JOYBUS: SerialControl = 0;
pub const SerialControl_SIO_IRQ_ENABLE: SerialControl = 16384;
pub type SerialControl = ::core::ffi::c_uint;
pub const RControl_R_MODE_SPI_8BIT: RControl = 0;
pub const RControl_R_MODE_SPI_32BIT: RControl = 0;
pub const RControl_R_MODE_MULTI: RControl = 0;
pub const RControl_R_MODE_UART: RControl = 0;
pub const RControl_R_MODE_RAW: RControl = 32768;
pub const RControl_R_MODE_JOYBUS: RControl = 49152;
pub type RControl = ::core::ffi::c_uint;
extern "C" {
    pub fn sramRead(dst: *mut ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramReadAt(dst: *mut ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramWrite(src: *const ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramWriteAt(src: *const ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramCompare(src: *const ::core::ffi::c_void, len: usize) -> usize;
}
extern "C" {
    pub fn sramCompareAt(src: *const ::core::ffi::c_void, len: usize, off: usize) -> usize;
}
extern "C" {
    pub fn sramClear(len: usize);
}
extern "C" {
    pub fn sramClearAt(len: usize, off: usize);
}
extern "C" {
    pub fn sramRead64(dst: *mut ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramReadAt64(dst: *mut ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramWrite64(src: *const ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramWriteAt64(src: *const ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramClear64(len: usize);
}
extern "C" {
    pub fn sramClearAt64(len: usize, off: usize);
}
pub const TimerControl_TIMER_FREQ_16MHZ: TimerControl = 0;
pub const TimerControl_TIMER_FREQ_262KHZ: TimerControl = 1;
pub const TimerControl_TIMER_FREQ_64KHZ: TimerControl = 2;
pub const TimerControl_TIMER_FREQ_16KHZ: TimerControl = 3;
pub const TimerControl_TIMER_FREQ_CASCADE: TimerControl = 4;
pub const TimerControl_TIMER_IRQ_ENABLE: TimerControl = 64;
pub const TimerControl_TIMER_ENABLE: TimerControl = 128;
pub type TimerControl = ::core::ffi::c_uint;
extern "C" {
    pub fn timerSet(num: u32, reload: u16, flags: u16);
}
extern "C" {
    pub fn timerEnable(num: u32);
}
extern "C" {
    pub fn timerDisable(num: u32);
}
extern "C" {
    pub fn timerGetValue(num: u32) -> u16;
}
pub const LCDDimensions_LCD_WIDTH: LCDDimensions = 240;
pub const LCDDimensions_LCD_HEIGHT: LCDDimensions = 160;
pub const LCDDimensions_LCD_SCANLINES: LCDDimensions = 228;
pub type LCDDimensions = ::core::ffi::c_uint;
pub const DisplayControl_VIDEO_MODE_REGULAR: DisplayControl = 0;
pub const DisplayControl_VIDEO_MODE_MIXED: DisplayControl = 1;
pub const DisplayControl_VIDEO_MODE_AFFINE: DisplayControl = 2;
pub const DisplayControl_VIDEO_MODE_BITMAP: DisplayControl = 3;
pub const DisplayControl_VIDEO_MODE_BITMAP_INDEXED: DisplayControl = 4;
pub const DisplayControl_VIDEO_MODE_BITMAP_SMALL: DisplayControl = 5;
pub const DisplayControl_VIDEO_FRAME_SELECT: DisplayControl = 16;
pub const DisplayControl_VIDEO_OBJ_LAYOUT_1D: DisplayControl = 64;
pub const DisplayControl_VIDEO_OBJ_LAYOUT_2D: DisplayControl = 0;
pub const DisplayControl_VIDEO_FORCE_BLANK: DisplayControl = 128;
pub const DisplayControl_VIDEO_BG0_ENABLE: DisplayControl = 256;
pub const DisplayControl_VIDEO_BG1_ENABLE: DisplayControl = 512;
pub const DisplayControl_VIDEO_BG2_ENABLE: DisplayControl = 1024;
pub const DisplayControl_VIDEO_BG3_ENABLE: DisplayControl = 2048;
pub const DisplayControl_VIDEO_OBJ_ENABLE: DisplayControl = 4096;
pub const DisplayControl_VIDEO_WIN0_ENABLE: DisplayControl = 8192;
pub const DisplayControl_VIDEO_WIN1_ENABLE: DisplayControl = 16384;
pub const DisplayControl_VIDEO_OBJ_WIN_ENABLE: DisplayControl = 32768;
pub type DisplayControl = ::core::ffi::c_uint;
pub const DisplayStatus_LCD_IN_VBLANK: DisplayStatus = 1;
pub const DisplayStatus_LCD_IN_HBLANK: DisplayStatus = 2;
pub const DisplayStatus_LCD_VCOUNT_MATCH: DisplayStatus = 4;
pub const DisplayStatus_LCD_VBLANK_IRQ_ENABLE: DisplayStatus = 8;
pub const DisplayStatus_LCD_HBLANK_IRQ_ENABLE: DisplayStatus = 16;
pub const DisplayStatus_LCD_VCOUNT_IRQ_ENABLE: DisplayStatus = 32;
pub type DisplayStatus = ::core::ffi::c_uint;
pub const VerticalCount_VCOUNT_DRAW_START: VerticalCount = 0;
pub const VerticalCount_VCOUNT_DRAW_END: VerticalCount = 160;
pub const VerticalCount_VCOUNT_BLANK_START: VerticalCount = 160;
pub const VerticalCount_VCOUNT_BLANK_END: VerticalCount = 0;
pub type VerticalCount = ::core::ffi::c_uint;
pub const BackgroundControl_BG_PRIORITY_MIN: BackgroundControl = 3;
pub const BackgroundControl_BG_PRIORITY_MAX: BackgroundControl = 0;
pub const BackgroundControl_BG_MOSAIC_ENABLE: BackgroundControl = 64;
pub const BackgroundControl_BG_TILE_8BPP: BackgroundControl = 128;
pub const BackgroundControl_BG_TILE_4BPP: BackgroundControl = 0;
pub const BackgroundControl_BG_AFFINE_WRAP: BackgroundControl = 8192;
pub const BackgroundControl_BG_SIZE_256X256: BackgroundControl = 0;
pub const BackgroundControl_BG_SIZE_512X256: BackgroundControl = 16384;
pub const BackgroundControl_BG_SIZE_256X512: BackgroundControl = 32768;
pub const BackgroundControl_BG_SIZE_512X512: BackgroundControl = 49152;
pub const BackgroundControl_BG_AFFINE_SIZE_128X128: BackgroundControl = 0;
pub const BackgroundControl_BG_AFFINE_SIZE_256X256: BackgroundControl = 16384;
pub const BackgroundControl_BG_AFFINE_SIZE_512X512: BackgroundControl = 32768;
pub const BackgroundControl_BG_AFFINE_SIZE_1024X1024: BackgroundControl = 49152;
pub type BackgroundControl = ::core::ffi::c_uint;
pub const Waitstate_WAIT_SRAM_4: Waitstate = 0;
pub const Waitstate_WAIT_SRAM_3: Waitstate = 1;
pub const Waitstate_WAIT_SRAM_2: Waitstate = 2;
pub const Waitstate_WAIT_SRAM_8: Waitstate = 3;
pub const Waitstate_WAIT_ROM_N_4: Waitstate = 0;
pub const Waitstate_WAIT_ROM_N_3: Waitstate = 4;
pub const Waitstate_WAIT_ROM_N_2: Waitstate = 8;
pub const Waitstate_WAIT_ROM_N_8: Waitstate = 12;
pub const Waitstate_WAIT_ROM_S_2: Waitstate = 0;
pub const Waitstate_WAIT_ROM_S_1: Waitstate = 16;
pub const Waitstate_WAIT_PREFETCH_ENABLE: Waitstate = 16384;
pub type Waitstate = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BgAffineSrcData {
    pub src_center_x: i32,
    pub src_center_y: i32,
    pub disp_center_x: i16,
    pub disp_center_y: i16,
    pub ratio_x: i16,
    pub ratio_y: i16,
    pub theta: u16,
}
#[test]
fn bindgen_test_layout_BgAffineSrcData() {
    const UNINIT: ::core::mem::MaybeUninit<BgAffineSrcData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BgAffineSrcData>(),
        20usize,
        concat!("Size of: ", stringify!(BgAffineSrcData))
    );
    assert_eq!(
        ::core::mem::align_of::<BgAffineSrcData>(),
        4usize,
        concat!("Alignment of ", stringify!(BgAffineSrcData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_center_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(src_center_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_center_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(src_center_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disp_center_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(disp_center_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disp_center_y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(disp_center_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(ratio_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(ratio_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).theta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(theta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BgAffineDstData {
    pub h_diff_x: i16,
    pub v_diff_x: i16,
    pub h_diff_y: i16,
    pub v_diff_y: i16,
    pub start_x: i32,
    pub start_y: i32,
}
#[test]
fn bindgen_test_layout_BgAffineDstData() {
    const UNINIT: ::core::mem::MaybeUninit<BgAffineDstData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BgAffineDstData>(),
        16usize,
        concat!("Size of: ", stringify!(BgAffineDstData))
    );
    assert_eq!(
        ::core::mem::align_of::<BgAffineDstData>(),
        4usize,
        concat!("Alignment of ", stringify!(BgAffineDstData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(h_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_x) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(v_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(h_diff_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(v_diff_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(start_y)
        )
    );
}
extern "C" {
    pub fn biosBgAffineSet(src: *const BgAffineSrcData, dst: *mut BgAffineDstData, num: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjAffineSrcData {
    pub ratio_x: i16,
    pub ratio_y: i16,
    pub theta: u16,
    pub pad: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_ObjAffineSrcData() {
    const UNINIT: ::core::mem::MaybeUninit<ObjAffineSrcData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ObjAffineSrcData>(),
        8usize,
        concat!("Size of: ", stringify!(ObjAffineSrcData))
    );
    assert_eq!(
        ::core::mem::align_of::<ObjAffineSrcData>(),
        2usize,
        concat!("Alignment of ", stringify!(ObjAffineSrcData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(ratio_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(ratio_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).theta) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(theta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjAffineDstData {
    pub h_diff_x: i16,
    pub v_diff_x: i16,
    pub h_diff_y: i16,
    pub v_diff_y: i16,
}
#[test]
fn bindgen_test_layout_ObjAffineDstData() {
    const UNINIT: ::core::mem::MaybeUninit<ObjAffineDstData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ObjAffineDstData>(),
        8usize,
        concat!("Size of: ", stringify!(ObjAffineDstData))
    );
    assert_eq!(
        ::core::mem::align_of::<ObjAffineDstData>(),
        2usize,
        concat!("Alignment of ", stringify!(ObjAffineDstData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(h_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_x) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(v_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(h_diff_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(v_diff_y)
        )
    );
}
pub const ObjAffineSetOffset_OAS_OFFSET_DSTDATA: ObjAffineSetOffset = 2;
pub const ObjAffineSetOffset_OAS_OFFSET_OAM: ObjAffineSetOffset = 8;
pub type ObjAffineSetOffset = ::core::ffi::c_uint;
extern "C" {
    pub fn biosObjAffineSet(
        src: *const ObjAffineSrcData,
        dst: *mut ::core::ffi::c_void,
        num: u32,
        offset: u32,
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct BitUnPackParam {
    pub src_length: u16,
    pub src_width: u8,
    pub dst_width: u8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_BitUnPackParam() {
    const UNINIT: ::core::mem::MaybeUninit<BitUnPackParam> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BitUnPackParam>(),
        8usize,
        concat!("Size of: ", stringify!(BitUnPackParam))
    );
    assert_eq!(
        ::core::mem::align_of::<BitUnPackParam>(),
        4usize,
        concat!("Alignment of ", stringify!(BitUnPackParam))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitUnPackParam),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_width) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BitUnPackParam),
            "::",
            stringify!(src_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_width) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BitUnPackParam),
            "::",
            stringify!(dst_width)
        )
    );
}
impl BitUnPackParam {
    #[inline]
    pub fn offset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_zeroes(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_zeroes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32, keep_zeroes: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let keep_zeroes: u32 = unsafe { ::core::mem::transmute(keep_zeroes) };
            keep_zeroes as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn biosBitUnPack(
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        param: *const BitUnPackParam,
    );
}
extern "C" {
    pub fn biosLZ77UnCompWram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosLZ77UnCompVram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosHuffUnComp(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosRLUnCompWram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosRLUnCompVram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosDiff8bitUnFilterWram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosDiff8bitUnFilterVram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosDiff16bitUnFilter(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Div {
    pub quot: i32,
    pub rem: i32,
}
#[test]
fn bindgen_test_layout_Div() {
    const UNINIT: ::core::mem::MaybeUninit<Div> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Div>(),
        8usize,
        concat!("Size of: ", stringify!(Div))
    );
    assert_eq!(
        ::core::mem::align_of::<Div>(),
        4usize,
        concat!("Alignment of ", stringify!(Div))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Div), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Div), "::", stringify!(rem))
    );
}
extern "C" {
    pub fn biosDiv(numerator: i32, denominator: i32) -> i32;
}
extern "C" {
    pub fn biosDivMod(numerator: i32, denominator: i32) -> Div;
}
extern "C" {
    pub fn biosSqrt(x: u32) -> u16;
}
extern "C" {
    pub fn biosArcTan(tan: i16) -> i16;
}
extern "C" {
    pub fn biosArcTan2(x: i16, y: i16) -> u16;
}
pub const CpuSetFlags_CS_SRC_FIXED: CpuSetFlags = 16777216;
pub const CpuSetFlags_CS_32BIT: CpuSetFlags = 67108864;
pub const CpuSetFlags_CS_16BIT: CpuSetFlags = 0;
pub type CpuSetFlags = ::core::ffi::c_uint;
pub const CpuFastSetFlags_CFS_SRC_FIXED: CpuFastSetFlags = 16777216;
pub type CpuFastSetFlags = ::core::ffi::c_uint;
extern "C" {
    pub fn biosCpuSet(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void, ctrl: u32);
}
extern "C" {
    pub fn biosCpuFastSet(
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        ctrl: u32,
    );
}
extern "C" {
    pub fn biosSoftReset() -> !;
}
extern "C" {
    pub fn biosHardReset() -> !;
}
pub const SoftResetExFlags_SRE_FROM_ROM: SoftResetExFlags = 0;
pub const SoftResetExFlags_SRE_FROM_RAM: SoftResetExFlags = 1;
pub type SoftResetExFlags = ::core::ffi::c_uint;
extern "C" {
    pub fn biosSoftResetEx(reset_flags: u8, from_ewram: bool) -> !;
}
pub const RegisterRamResetFlags_RRR_EWRAM: RegisterRamResetFlags = 1;
pub const RegisterRamResetFlags_RRR_IWRAM: RegisterRamResetFlags = 2;
pub const RegisterRamResetFlags_RRR_PALETTE: RegisterRamResetFlags = 4;
pub const RegisterRamResetFlags_RRR_VRAM: RegisterRamResetFlags = 8;
pub const RegisterRamResetFlags_RRR_OAM: RegisterRamResetFlags = 16;
pub const RegisterRamResetFlags_RRR_SIO: RegisterRamResetFlags = 32;
pub const RegisterRamResetFlags_RRR_SOUND: RegisterRamResetFlags = 64;
pub const RegisterRamResetFlags_RRR_REGISTERS: RegisterRamResetFlags = 128;
pub const RegisterRamResetFlags_RRR_EVERYTHING: RegisterRamResetFlags = 255;
pub type RegisterRamResetFlags = ::core::ffi::c_uint;
extern "C" {
    pub fn biosRegisterRamReset(reset_flags: u8);
}
extern "C" {
    pub fn biosSoundDriverMain();
}
extern "C" {
    pub fn biosSoundDriverVSync();
}
extern "C" {
    pub fn biosSoundChannelClear();
}
extern "C" {
    pub fn biosSoundDriverVSyncOff();
}
extern "C" {
    pub fn biosSoundDriverVSyncOn();
}
pub const BiosChecksum_BIOS_CHECKSUM_GBA: BiosChecksum = 3131971711;
pub const BiosChecksum_BIOS_CHECKSUM_NDS: BiosChecksum = 3131971712;
pub type BiosChecksum = ::core::ffi::c_uint;
extern "C" {
    pub fn biosBiosChecksum() -> u32;
}
extern "C" {
    pub fn biosHalt();
}
extern "C" {
    pub fn biosStop();
}
extern "C" {
    pub fn biosIntrWait(wait_next: bool, intr_flags: u16);
}
extern "C" {
    pub fn biosVBlankIntrWait();
}
pub const SerialControlSPI_SPI_CLOCK_EXTERNAL: SerialControlSPI = 0;
pub const SerialControlSPI_SPI_CLOCK_256KHZ: SerialControlSPI = 1;
pub const SerialControlSPI_SPI_CLOCK_2MHZ: SerialControlSPI = 3;
pub const SerialControlSPI_SPI_SI_STATE: SerialControlSPI = 4;
pub const SerialControlSPI_SPI_SO_HIGH: SerialControlSPI = 8;
pub const SerialControlSPI_SPI_SO_LOW: SerialControlSPI = 0;
pub const SerialControlSPI_SPI_START: SerialControlSPI = 128;
pub type SerialControlSPI = ::core::ffi::c_uint;
pub const SerialControlUART_UART_BAUD_9600: SerialControlUART = 0;
pub const SerialControlUART_UART_BAUD_38400: SerialControlUART = 1;
pub const SerialControlUART_UART_BAUD_57600: SerialControlUART = 2;
pub const SerialControlUART_UART_BAUD_115200: SerialControlUART = 3;
pub const SerialControlUART_UART_CTS_ENABLE: SerialControlUART = 4;
pub const SerialControlUART_UART_PARITY_ODD: SerialControlUART = 8;
pub const SerialControlUART_UART_PARITY_EVEN: SerialControlUART = 0;
pub const SerialControlUART_UART_SEND_FULL: SerialControlUART = 16;
pub const SerialControlUART_UART_RECEIVE_EMPTY: SerialControlUART = 32;
pub const SerialControlUART_UART_ERROR: SerialControlUART = 64;
pub const SerialControlUART_UART_8BIT: SerialControlUART = 256;
pub const SerialControlUART_UART_7BIT: SerialControlUART = 0;
pub const SerialControlUART_UART_FIFO_ENABLE: SerialControlUART = 256;
pub const SerialControlUART_UART_PARITY_ENABLE: SerialControlUART = 512;
pub const SerialControlUART_UART_SEND_ENABLE: SerialControlUART = 1024;
pub const SerialControlUART_UART_RECEIVE_ENABLE: SerialControlUART = 2048;
pub type SerialControlUART = ::core::ffi::c_uint;
pub type Color = u16;
pub type Palette = [Color; 256usize];
pub type PaletteBank = [Color; 16usize];
pub type MapEntry = u16;
pub type AffineMapEntry = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Matrix {
    pub hdx: i16,
    pub vdx: i16,
    pub hdy: i16,
    pub vdy: i16,
}
#[test]
fn bindgen_test_layout_Matrix() {
    const UNINIT: ::core::mem::MaybeUninit<Matrix> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Matrix>(),
        8usize,
        concat!("Size of: ", stringify!(Matrix))
    );
    assert_eq!(
        ::core::mem::align_of::<Matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(Matrix))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(hdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vdx) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(vdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(hdy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vdy) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(vdy)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Object {
    pub attr0: u16,
    pub attr1: u16,
    pub attr2: u16,
    pub _reserved: u16,
}
#[test]
fn bindgen_test_layout_Object() {
    const UNINIT: ::core::mem::MaybeUninit<Object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Object>(),
        8usize,
        concat!("Size of: ", stringify!(Object))
    );
    assert_eq!(
        ::core::mem::align_of::<Object>(),
        4usize,
        concat!("Alignment of ", stringify!(Object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(attr0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(attr1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(attr2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(_reserved)
        )
    );
}
pub type Mode3Frame = [[u16; 240usize]; 160usize];
pub type Mode4Frame = [[u16; 120usize]; 160usize];
pub type Mode5Frame = [[u16; 160usize]; 128usize];
pub const Tile_TILE_FLIP_H: Tile = 1024;
pub const Tile_TILE_FLIP_V: Tile = 2048;
pub type Tile = ::core::ffi::c_uint;
pub const BlendControl_BLEND_TARGET_BG0: BlendControl = 1;
pub const BlendControl_BLEND_TARGET_BG1: BlendControl = 2;
pub const BlendControl_BLEND_TARGET_BG2: BlendControl = 4;
pub const BlendControl_BLEND_TARGET_BG3: BlendControl = 8;
pub const BlendControl_BLEND_TARGET_OBJ: BlendControl = 16;
pub const BlendControl_BLEND_TARGET_BD: BlendControl = 32;
pub const BlendControl_BLEND_MODE_NONE: BlendControl = 0;
pub const BlendControl_BLEND_MODE_ALPHA: BlendControl = 64;
pub const BlendControl_BLEND_MODE_WHITE: BlendControl = 128;
pub const BlendControl_BLEND_MODE_BLACK: BlendControl = 192;
pub const BlendControl_BLEND_TARGET2_BG0: BlendControl = 256;
pub const BlendControl_BLEND_TARGET2_BG1: BlendControl = 512;
pub const BlendControl_BLEND_TARGET2_BG2: BlendControl = 1024;
pub const BlendControl_BLEND_TARGET2_BG3: BlendControl = 2048;
pub const BlendControl_BLEND_TARGET2_OBJ: BlendControl = 4096;
pub const BlendControl_BLEND_TARGET2_BD: BlendControl = 8192;
pub type BlendControl = ::core::ffi::c_uint;
pub const ColorConstants_COLOR_RED: ColorConstants = 31;
pub const ColorConstants_COLOR_RED_ORANGE: ColorConstants = 287;
pub const ColorConstants_COLOR_ORANGE: ColorConstants = 511;
pub const ColorConstants_COLOR_ORANGE_YELLOW: ColorConstants = 767;
pub const ColorConstants_COLOR_YELLOW: ColorConstants = 1023;
pub const ColorConstants_COLOR_YELLOW_LIME: ColorConstants = 1015;
pub const ColorConstants_COLOR_LIME: ColorConstants = 1007;
pub const ColorConstants_COLOR_LIME_GREEN: ColorConstants = 1000;
pub const ColorConstants_COLOR_GREEN: ColorConstants = 992;
pub const ColorConstants_COLOR_GREEN_MINT: ColorConstants = 9184;
pub const ColorConstants_COLOR_MINT: ColorConstants = 16352;
pub const ColorConstants_COLOR_MINT_CYAN: ColorConstants = 24544;
pub const ColorConstants_COLOR_CYAN: ColorConstants = 32736;
pub const ColorConstants_COLOR_CYAN_SKYBLUE: ColorConstants = 32480;
pub const ColorConstants_COLOR_SKYBLUE: ColorConstants = 32224;
pub const ColorConstants_COLOR_SKYBLUE_BLUE: ColorConstants = 32000;
pub const ColorConstants_COLOR_BLUE: ColorConstants = 31744;
pub const ColorConstants_COLOR_BLUE_PURPLE: ColorConstants = 31752;
pub const ColorConstants_COLOR_PURPLE: ColorConstants = 31759;
pub const ColorConstants_COLOR_PURPLE_MAGENTA: ColorConstants = 31767;
pub const ColorConstants_COLOR_MAGENTA: ColorConstants = 31775;
pub const ColorConstants_COLOR_MAGENTA_PINK: ColorConstants = 23583;
pub const ColorConstants_COLOR_PINK: ColorConstants = 15391;
pub const ColorConstants_COLOR_PINK_RED: ColorConstants = 8223;
pub const ColorConstants_COLOR_BLACK: ColorConstants = 0;
pub const ColorConstants_COLOR_WHITE: ColorConstants = 32767;
pub const ColorConstants_COLOR_GRAY_0: ColorConstants = 0;
pub const ColorConstants_COLOR_GRAY_5: ColorConstants = 2114;
pub const ColorConstants_COLOR_GRAY_10: ColorConstants = 3171;
pub const ColorConstants_COLOR_GRAY_15: ColorConstants = 5285;
pub const ColorConstants_COLOR_GRAY_20: ColorConstants = 6342;
pub const ColorConstants_COLOR_GRAY_25: ColorConstants = 8456;
pub const ColorConstants_COLOR_GRAY_30: ColorConstants = 9513;
pub const ColorConstants_COLOR_GRAY_35: ColorConstants = 11627;
pub const ColorConstants_COLOR_GRAY_40: ColorConstants = 12684;
pub const ColorConstants_COLOR_GRAY_45: ColorConstants = 14798;
pub const ColorConstants_COLOR_GRAY_50: ColorConstants = 15855;
pub const ColorConstants_COLOR_GRAY_55: ColorConstants = 17969;
pub const ColorConstants_COLOR_GRAY_60: ColorConstants = 20083;
pub const ColorConstants_COLOR_GRAY_65: ColorConstants = 21140;
pub const ColorConstants_COLOR_GRAY_70: ColorConstants = 23254;
pub const ColorConstants_COLOR_GRAY_75: ColorConstants = 24311;
pub const ColorConstants_COLOR_GRAY_80: ColorConstants = 26425;
pub const ColorConstants_COLOR_GRAY_85: ColorConstants = 27482;
pub const ColorConstants_COLOR_GRAY_90: ColorConstants = 29596;
pub const ColorConstants_COLOR_GRAY_95: ColorConstants = 30653;
pub const ColorConstants_COLOR_GRAY_100: ColorConstants = 32767;
pub type ColorConstants = ::core::ffi::c_uint;
extern "C" {
    pub fn oamWriteObjects(oam_index: usize, objs: *mut Object, n_objs: usize) -> usize;
}
extern "C" {
    pub fn oamWriteObjectsUnchecked(oam_index: usize, objs: *mut Object, n_objs: usize) -> usize;
}
extern "C" {
    pub fn oamWriteMatrices(oam_index: usize, mats: *mut Matrix, n_mats: usize) -> usize;
}
extern "C" {
    pub fn oamWriteMatricesUnchecked(oam_index: usize, mats: *mut Matrix, n_mats: usize) -> usize;
}
pub const ObjectAttribute0_OBJ_MODE_REGULAR: ObjectAttribute0 = 0;
pub const ObjectAttribute0_OBJ_MODE_AFFINE: ObjectAttribute0 = 256;
pub const ObjectAttribute0_OBJ_MODE_HIDDEN: ObjectAttribute0 = 512;
pub const ObjectAttribute0_OBJ_MODE_DOUBLE: ObjectAttribute0 = 768;
pub const ObjectAttribute0_OBJ_TYPE_REGULAR: ObjectAttribute0 = 0;
pub const ObjectAttribute0_OBJ_TYPE_BLEND: ObjectAttribute0 = 1024;
pub const ObjectAttribute0_OBJ_TYPE_WINDOW: ObjectAttribute0 = 2048;
pub const ObjectAttribute0_OBJ_MOSAIC_ENABLE: ObjectAttribute0 = 4096;
pub const ObjectAttribute0_OBJ_TILE_8BPP: ObjectAttribute0 = 8192;
pub const ObjectAttribute0_OBJ_TILE_4BPP: ObjectAttribute0 = 0;
pub const ObjectAttribute0_OBJ_SHAPE_SQUARE: ObjectAttribute0 = 0;
pub const ObjectAttribute0_OBJ_SHAPE_WIDE: ObjectAttribute0 = 16384;
pub const ObjectAttribute0_OBJ_SHAPE_TALL: ObjectAttribute0 = 32768;
pub type ObjectAttribute0 = ::core::ffi::c_uint;
pub const ObjectAttribute1_OBJ_FLIP_H: ObjectAttribute1 = 4096;
pub const ObjectAttribute1_OBJ_FLIP_V: ObjectAttribute1 = 8192;
pub const ObjectAttribute1_OBJ_SIZE_8X8: ObjectAttribute1 = 0;
pub const ObjectAttribute1_OBJ_SIZE_16X16: ObjectAttribute1 = 16384;
pub const ObjectAttribute1_OBJ_SIZE_32X32: ObjectAttribute1 = 32768;
pub const ObjectAttribute1_OBJ_SIZE_64X64: ObjectAttribute1 = 49152;
pub const ObjectAttribute1_OBJ_SIZE_16X8: ObjectAttribute1 = 0;
pub const ObjectAttribute1_OBJ_SIZE_32X8: ObjectAttribute1 = 16384;
pub const ObjectAttribute1_OBJ_SIZE_32X16: ObjectAttribute1 = 32768;
pub const ObjectAttribute1_OBJ_SIZE_64X32: ObjectAttribute1 = 49152;
pub const ObjectAttribute1_OBJ_SIZE_8X16: ObjectAttribute1 = 0;
pub const ObjectAttribute1_OBJ_SIZE_8X32: ObjectAttribute1 = 16384;
pub const ObjectAttribute1_OBJ_SIZE_16X32: ObjectAttribute1 = 32768;
pub const ObjectAttribute1_OBJ_SIZE_32X64: ObjectAttribute1 = 49152;
pub type ObjectAttribute1 = ::core::ffi::c_uint;
pub const ObjectAttribute2_OBJ_PRIORITY_MIN: ObjectAttribute2 = 3072;
pub const ObjectAttribute2_OBJ_PROIRITY_MAX: ObjectAttribute2 = 0;
pub type ObjectAttribute2 = ::core::ffi::c_uint;
pub const WindowControl_WINDOW_BG0_ENABLE: WindowControl = 1;
pub const WindowControl_WINDOW_BG1_ENABLE: WindowControl = 2;
pub const WindowControl_WINDOW_BG2_ENABLE: WindowControl = 4;
pub const WindowControl_WINDOW_BG3_ENABLE: WindowControl = 8;
pub const WindowControl_WINDOW_OBJ_ENABLE: WindowControl = 16;
pub const WindowControl_WINDOW_BLEND_ENABLE: WindowControl = 32;
pub type WindowControl = ::core::ffi::c_uint;
pub type AssertHandlerFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: u32,
    ),
>;
extern "C" {
    pub fn assertSetHandler(handler: AssertHandlerFn) -> AssertHandlerFn;
}
extern "C" {
    pub fn assertGetHandler() -> AssertHandlerFn;
}
extern "C" {
    pub fn assertRaise(
        message: *const ::core::ffi::c_char,
        function: *const ::core::ffi::c_char,
        file: *const ::core::ffi::c_char,
        line: u32,
    ) -> !;
}
extern "C" {
    pub fn bitCTZ32(value: u32) -> u32;
}
extern "C" {
    pub fn bitCTZ16(value: u16) -> u32;
}
extern "C" {
    pub fn bitCTZ8(value: u8) -> u32;
}
extern "C" {
    pub fn bitCLZ32(value: u32) -> u32;
}
extern "C" {
    pub fn bitCLZ16(value: u16) -> u32;
}
extern "C" {
    pub fn bitCLZ8(value: u8) -> u32;
}
pub const DebugException_EXCEPTION_UNDEFINED_INSTRUCTION: DebugException = 0;
pub const DebugException_EXCEPTION_PREFETCH_ABORT: DebugException = 1;
pub const DebugException_EXCEPTION_DATA_ABORT: DebugException = 2;
pub const DebugException_EXCEPTION_IRQ: DebugException = 3;
pub const DebugException_EXCEPTION_FIQ: DebugException = 4;
pub type DebugException = ::core::ffi::c_uint;
extern "C" {
    pub fn dbgRaiseException(exception: u32) -> bool;
}
pub const LogLevel_LOG_OFF: LogLevel = 0;
pub const LogLevel_LOG_FATAL: LogLevel = 1;
pub const LogLevel_LOG_ERROR: LogLevel = 2;
pub const LogLevel_LOG_WARN: LogLevel = 3;
pub const LogLevel_LOG_INFO: LogLevel = 4;
pub const LogLevel_LOG_DEBUG: LogLevel = 5;
pub const LogLevel_LOG_TRACE: LogLevel = 6;
pub type LogLevel = ::core::ffi::c_uint;
pub const LogInterface_LOGIF_NONE: LogInterface = 0;
pub const LogInterface_LOGIF_MGBA: LogInterface = 1;
pub const LogInterface_LOGIF_NOCASH: LogInterface = 2;
pub const LogInterface_LOGIF_VBA: LogInterface = 3;
pub const LogInterface_LOGIF_CUSTOM: LogInterface = 255;
pub type LogInterface = ::core::ffi::c_uint;
pub type LogCustomOutputFunction =
    ::core::option::Option<unsafe extern "C" fn(arg1: u8, arg2: *const ::core::ffi::c_char)>;
extern "C" {
    pub fn logInit() -> u8;
}
extern "C" {
    pub fn logInitInterface(interface: u8) -> bool;
}
extern "C" {
    pub fn logInitCustom(f: LogCustomOutputFunction);
}
extern "C" {
    pub fn logGetInterface() -> u8;
}
extern "C" {
    pub fn logGetInterfaceName() -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn logSetMaxLevel(level: u8);
}
extern "C" {
    pub fn logGetMaxLevel() -> u8;
}
extern "C" {
    pub fn logOutput(level: u8, message: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn profileRun(
        function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        data: *mut ::core::ffi::c_void,
    ) -> u32;
}
extern "C" {
    pub fn randSetSeed(seed: u32);
}
extern "C" {
    pub fn randNext() -> u32;
}
pub const SIMDMask_SIMD_MASK_4X8: SIMDMask = 2155905152;
pub const SIMDMask_SIMD_MASK_2X16: SIMDMask = 2147516416;
pub const SIMDMask_SIMD_MASK_2XRGB: SIMDMask = 3255878160;
pub type SIMDMask = ::core::ffi::c_uint;
extern "C" {
    pub fn simdAdd(
        mask: u32,
        lhs: *mut ::core::ffi::c_void,
        rhs: *const ::core::ffi::c_void,
        len: usize,
    );
}
extern "C" {
    pub fn simdSub(
        mask: u32,
        lhs: *mut ::core::ffi::c_void,
        rhs: *const ::core::ffi::c_void,
        len: usize,
    );
}
