/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const LIBSEVEN_VERSION_MAJOR: u32 = 0;
pub const LIBSEVEN_VERSION_MINOR: u32 = 17;
pub const LIBSEVEN_VERSION_PATCH: u32 = 2;
pub const BF_PSR_MODE_OFFSET: u32 = 0;
pub const BF_PSR_MODE_LENGTH: u32 = 5;
pub const BF_PSR_CONTROL_BITS_OFFSET: u32 = 0;
pub const BF_PSR_CONTROL_BITS_LENGTH: u32 = 8;
pub const BF_PSR_FLAGS_OFFSET: u32 = 28;
pub const BF_PSR_FLAGS_LENGTH: u32 = 4;
pub const BF_DMA_DST_OFFSET: u32 = 5;
pub const BF_DMA_DST_LENGTH: u32 = 2;
pub const BF_DMA_SRC_OFFSET: u32 = 7;
pub const BF_DMA_SRC_LENGTH: u32 = 2;
pub const BF_DMA_START_OFFSET: u32 = 12;
pub const BF_DMA_START_LENGTH: u32 = 2;
pub const BF_SIO_MODE_OFFSET: u32 = 12;
pub const BF_SIO_MODE_LENGTH: u32 = 2;
pub const BF_R_MODE_OFFSET: u32 = 14;
pub const BF_R_MODE_LENGTH: u32 = 2;
pub const BF_TIMER_FREQ_OFFSET: u32 = 0;
pub const BF_TIMER_FREQ_LENGTH: u32 = 3;
pub const BF_VIDEO_MODE_OFFSET: u32 = 0;
pub const BF_VIDEO_MODE_LENGTH: u32 = 3;
pub const BF_LCD_TARGET_VCOUNT_OFFSET: u32 = 8;
pub const BF_LCD_TARGET_VCOUNT_LENGTH: u32 = 8;
pub const BF_BG_PRIORITY_OFFSET: u32 = 0;
pub const BF_BG_PRIORITY_LENGTH: u32 = 2;
pub const BF_BG_GFX_BASE_OFFSET: u32 = 2;
pub const BF_BG_GFX_BASE_LENGTH: u32 = 2;
pub const BF_BG_MAP_BASE_OFFSET: u32 = 8;
pub const BF_BG_MAP_BASE_LENGTH: u32 = 5;
pub const BF_BG_SIZE_OFFSET: u32 = 14;
pub const BF_BG_SIZE_LENGTH: u32 = 2;
pub const BF_BG_AFFINE_SIZE_OFFSET: u32 = 14;
pub const BF_BG_AFFINE_SIZE_LENGTH: u32 = 2;
pub const BF_WAIT_SRAM_OFFSET: u32 = 0;
pub const BF_WAIT_SRAM_LENGTH: u32 = 2;
pub const BF_WAIT_ROM_N_OFFSET: u32 = 2;
pub const BF_WAIT_ROM_N_LENGTH: u32 = 2;
pub const BF_WAIT_ROM_S_OFFSET: u32 = 4;
pub const BF_WAIT_ROM_S_LENGTH: u32 = 1;
pub const BF_MULTI_BAUD_OFFSET: u32 = 0;
pub const BF_MULTI_BAUD_LENGTH: u32 = 2;
pub const BF_MULTI_CLIENT_ID_OFFSET: u32 = 4;
pub const BF_MULTI_CLIENT_ID_LENGTH: u32 = 2;
pub const BF_SPI_CLOCK_OFFSET: u32 = 0;
pub const BF_SPI_CLOCK_LENGTH: u32 = 2;
pub const BF_UART_BAUD_OFFSET: u32 = 0;
pub const BF_UART_BAUD_LENGTH: u32 = 2;
pub const MODE3_WIDTH: u32 = 240;
pub const MODE3_HEIGHT: u32 = 160;
pub const MODE4_WIDTH: u32 = 240;
pub const MODE4_HEIGHT: u32 = 160;
pub const MODE5_WIDTH: u32 = 160;
pub const MODE5_HEIGHT: u32 = 128;
pub const BF_TILE_NUMBER_OFFSET: u32 = 0;
pub const BF_TILE_NUMBER_LENGTH: u32 = 10;
pub const BF_TILE_PALETTE_OFFSET: u32 = 12;
pub const BF_TILE_PALETTE_LENGTH: u32 = 4;
pub const BF_BLEND_MODE_OFFSET: u32 = 6;
pub const BF_BLEND_MODE_LENGTH: u32 = 2;
pub const BF_COLOR_R_OFFSET: u32 = 0;
pub const BF_COLOR_R_LENGTH: u32 = 5;
pub const BF_COLOR_G_OFFSET: u32 = 5;
pub const BF_COLOR_G_LENGTH: u32 = 5;
pub const BF_COLOR_B_OFFSET: u32 = 10;
pub const BF_COLOR_B_LENGTH: u32 = 5;
pub const BF_MOSAIC_BG_H_OFFSET: u32 = 0;
pub const BF_MOSAIC_BG_H_LENGTH: u32 = 4;
pub const BF_MOSAIC_BG_V_OFFSET: u32 = 4;
pub const BF_MOSAIC_BG_V_LENGTH: u32 = 4;
pub const BF_MOSAIC_OBJ_H_OFFSET: u32 = 8;
pub const BF_MOSAIC_OBJ_H_LENGTH: u32 = 4;
pub const BF_MOSAIC_OBJ_V_OFFSET: u32 = 12;
pub const BF_MOSAIC_OBJ_V_LENGTH: u32 = 4;
pub const BF_OBJ_Y_POS_OFFSET: u32 = 0;
pub const BF_OBJ_Y_POS_LENGTH: u32 = 8;
pub const BF_OBJ_MODE_OFFSET: u32 = 8;
pub const BF_OBJ_MODE_LENGTH: u32 = 2;
pub const BF_OBJ_TYPE_OFFSET: u32 = 10;
pub const BF_OBJ_TYPE_LENGTH: u32 = 2;
pub const BF_OBJ_SHAPE_OFFSET: u32 = 14;
pub const BF_OBJ_SHAPE_LENGTH: u32 = 2;
pub const BF_OBJ_X_POS_OFFSET: u32 = 0;
pub const BF_OBJ_X_POS_LENGTH: u32 = 9;
pub const BF_OBJ_AFFINE_MATRIX_OFFSET: u32 = 9;
pub const BF_OBJ_AFFINE_MATRIX_LENGTH: u32 = 5;
pub const BF_OBJ_SIZE_OFFSET: u32 = 14;
pub const BF_OBJ_SIZE_LENGTH: u32 = 2;
pub const BF_OBJ_TILE_NUMBER_OFFSET: u32 = 0;
pub const BF_OBJ_TILE_NUMBER_LENGTH: u32 = 10;
pub const BF_OBJ_PRIORITY_OFFSET: u32 = 10;
pub const BF_OBJ_PRIORITY_LENGTH: u32 = 2;
pub const BF_OBJ_PALETTE_NUMBER_OFFSET: u32 = 12;
pub const BF_OBJ_PALETTE_NUMBER_LENGTH: u32 = 4;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SoftwareInterruptNumber {
    SWI_SOFTRESET = 0,
    SWI_REGISTERRAMRESET = 1,
    SWI_HALT = 2,
    SWI_STOP = 3,
    SWI_INTRWAIT = 4,
    SWI_VBLANKINTRWAIT = 5,
    SWI_DIV = 6,
    SWI_SQRT = 8,
    SWI_ARCTAN = 9,
    SWI_ARCTAN2 = 10,
    SWI_CPUSET = 11,
    SWI_CPUFASTSET = 12,
    SWI_BIOSCHECKSUM = 13,
    SWI_BGAFFINESET = 14,
    SWI_OBJAFFINESET = 15,
    SWI_BITUNPACK = 16,
    SWI_LZ77UNCOMPWRAM = 17,
    SWI_LZ77UNCOMPVRAM = 18,
    SWI_HUFFUNCOMP = 19,
    SWI_RLUNCOMPWRAM = 20,
    SWI_RLUNCOMPVRAM = 21,
    SWI_DIFF8BITUNFILTERWRAM = 22,
    SWI_DIFF8BITUNFILTERVRAM = 23,
    SWI_DIFF16BITUNFILTER = 24,
    SWI_SOUNDBIAS = 25,
    SWI_SOUNDDRIVERINIT = 26,
    SWI_SOUNDDRIVERMODE = 27,
    SWI_SOUNDDRIVERMAIN = 28,
    SWI_SOUNDDRIVERVSYNC = 29,
    SWI_SOUNDCHANNELCLEAR = 30,
    SWI_MIDIKEY2FREQ = 31,
    SWI_MUSICPLAYEROPEN = 32,
    SWI_MUSICPLAYERSTART = 33,
    SWI_MUSICPLAYERSTOP = 34,
    SWI_MUSICPLAYERCONTINUE = 35,
    SWI_MUSICPLAYERFADEOUT = 36,
    SWI_MULTIBOOT = 37,
    SWI_HARDRESET = 38,
    SWI_SOUNDDRIVERVSYNCOFF = 40,
    SWI_SOUNDDRIVERVSYNCON = 41,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GpioDirection {
    GPIO_IN = 0,
    GPIO_OUT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GpioControl {
    GPIO_WRITEONLY = 0,
    GPIO_READWRITE = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ProgramStatusRegister {
    PSR_MODE_USR = 16,
    PSR_MODE_FIQ = 17,
    PSR_MODE_IRQ = 18,
    PSR_MODE_SVC = 19,
    PSR_MODE_ABT = 23,
    PSR_MODE_UND = 27,
    PSR_MODE_SYS = 31,
    PSR_STATE_THUMB = 32,
    PSR_FIQ_DISABLE = 64,
    PSR_IRQ_DISABLE = 128,
    PSR_FLAG_V = 268435456,
    PSR_FLAG_C = 536870912,
    PSR_FLAG_Z = 1073741824,
    PSR_FLAG_N = -2147483648,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA {
    pub src: *const ::core::ffi::c_void,
    pub dst: *mut ::core::ffi::c_void,
    pub len: u16,
    pub cnt: u16,
}
#[test]
fn bindgen_test_layout_DMA() {
    const UNINIT: ::core::mem::MaybeUninit<DMA> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA>(),
        12usize,
        concat!("Size of: ", stringify!(DMA))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(src))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(dst))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        10usize,
        concat!("Offset of field: ", stringify!(DMA), "::", stringify!(cnt))
    );
}
impl DMAControl {
    pub const DMA_SRC_INCREMENT: DMAControl = DMAControl::DMA_DST_INCREMENT;
}
impl DMAControl {
    pub const DMA_16BIT: DMAControl = DMAControl::DMA_DST_INCREMENT;
}
impl DMAControl {
    pub const DMA_START_NOW: DMAControl = DMAControl::DMA_DST_INCREMENT;
}
impl DMAControl {
    pub const DMA_START_CAPTURE: DMAControl = DMAControl::DMA_START_SOUND;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DMAControl {
    DMA_DST_INCREMENT = 0,
    DMA_DST_DECREMENT = 32,
    DMA_DST_FIXED = 64,
    DMA_DST_RELOAD = 96,
    DMA_SRC_DECREMENT = 128,
    DMA_SRC_FIXED = 256,
    DMA_REPEAT = 512,
    DMA_32BIT = 1024,
    DMA_START_HBLANK = 4096,
    DMA_START_VBLANK = 8192,
    DMA_START_SOUND = 12288,
    DMA_IRQ_ENABLE = 16384,
    DMA_ENABLE = 32768,
}
impl DMAControlPreset {
    pub const DMA_PRESET_CAPTURE: DMAControlPreset = DMAControlPreset::DMA_PRESET_SOUND;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DMAControlPreset {
    DMA_PRESET_COPY16 = 0,
    DMA_PRESET_COPY32 = 1024,
    DMA_PRESET_FILL16 = 256,
    DMA_PRESET_FILL32 = 1280,
    DMA_PRESET_HBLANK = 4608,
    DMA_PRESET_VBLANK = 8704,
    DMA_PRESET_SOUND = 12800,
}
extern "C" {
    pub fn dmaSet(channel: u32, dma: DMA);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Key {
    KEY_A = 1,
    KEY_B = 2,
    KEY_SELECT = 4,
    KEY_START = 8,
    KEY_RIGHT = 16,
    KEY_LEFT = 32,
    KEY_UP = 64,
    KEY_DOWN = 128,
    KEY_R = 256,
    KEY_L = 512,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KeyGroup {
    KEYS_DPAD_X = 48,
    KEYS_DPAD_Y = 192,
    KEYS_DPAD = 240,
    KEYS_AB = 3,
    KEYS_LR = 768,
    KEYS_STARTSELECT = 12,
    KEYS_BUTTONS = 783,
    KEYS_ALL = 1023,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KeyIndex {
    KEY_INDEX_A = 0,
    KEY_INDEX_B = 1,
    KEY_INDEX_SELECT = 2,
    KEY_INDEX_START = 3,
    KEY_INDEX_RIGHT = 4,
    KEY_INDEX_LEFT = 5,
    KEY_INDEX_UP = 6,
    KEY_INDEX_DOWN = 7,
    KEY_INDEX_R = 8,
    KEY_INDEX_L = 9,
    KEY_INDEX_MAX = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KeyIRQ {
    KEY_IRQ_ENABLE = 16384,
    KEY_IRQ_PRESS_ALL = 32768,
    KEY_IRQ_PRESS_ANY = 0,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct InputState {
    pub now: u16,
    pub last: u16,
}
#[test]
fn bindgen_test_layout_InputState() {
    const UNINIT: ::core::mem::MaybeUninit<InputState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputState>(),
        4usize,
        concat!("Size of: ", stringify!(InputState))
    );
    assert_eq!(
        ::core::mem::align_of::<InputState>(),
        4usize,
        concat!("Alignment of ", stringify!(InputState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).now) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputState),
            "::",
            stringify!(now)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(InputState),
            "::",
            stringify!(last)
        )
    );
}
extern "C" {
    pub fn inputNew() -> InputState;
}
extern "C" {
    pub fn inputPoll(i: InputState) -> InputState;
}
extern "C" {
    pub fn inputKeysPressed(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputKeysReleased(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputKeysDown(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputKeysUp(keys: u16, i: InputState) -> u16;
}
extern "C" {
    pub fn inputAxisX(i: InputState) -> i32;
}
extern "C" {
    pub fn inputAxisY(i: InputState) -> i32;
}
extern "C" {
    pub fn inputAxisLR(i: InputState) -> i32;
}
extern "C" {
    pub fn inputAxisAB(i: InputState) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRQ {
    IRQ_VBLANK = 1,
    IRQ_HBLANK = 2,
    IRQ_VCOUNT = 4,
    IRQ_TIMER_0 = 8,
    IRQ_TIMER_1 = 16,
    IRQ_TIMER_2 = 32,
    IRQ_TIMER_3 = 64,
    IRQ_SERIAL = 128,
    IRQ_DMA_0 = 256,
    IRQ_DMA_1 = 512,
    IRQ_DMA_2 = 1024,
    IRQ_DMA_3 = 2048,
    IRQ_KEYPAD = 4096,
    IRQ_CARTRIDGE = 8192,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRQGroup {
    IRQS_BLANK = 3,
    IRQS_TIMER = 120,
    IRQS_DMA = 3840,
    IRQS_EXTERNAL = 12416,
    IRQS_ALL = 16383,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRQIndex {
    IRQ_INDEX_VBLANK = 0,
    IRQ_INDEX_HBLANK = 1,
    IRQ_INDEX_VCOUNT = 2,
    IRQ_INDEX_TIMER_0 = 3,
    IRQ_INDEX_TIMER_1 = 4,
    IRQ_INDEX_TIMER_2 = 5,
    IRQ_INDEX_TIMER_3 = 6,
    IRQ_INDEX_SERIAL = 7,
    IRQ_INDEX_DMA_0 = 8,
    IRQ_INDEX_DMA_1 = 9,
    IRQ_INDEX_DMA_2 = 10,
    IRQ_INDEX_DMA_3 = 11,
    IRQ_INDEX_KEYPAD = 12,
    IRQ_INDEX_CARTRIDGE = 13,
    IRQ_INDEX_MAX = 14,
}
pub type IsrFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type IrqHandlerFn = ::core::option::Option<unsafe extern "C" fn(arg1: u16)>;
extern "C" {
    pub fn irqInit(isr: IsrFn);
}
extern "C" {
    pub fn irqInitDefault();
}
extern "C" {
    pub fn irqInitSimple(fn_: IrqHandlerFn);
}
extern "C" {
    pub fn irqInitStub();
}
extern "C" {
    pub fn irqHandlerSet(irq: u16, fn_: IrqHandlerFn) -> bool;
}
extern "C" {
    pub fn irqHandlerGet(irq: u16, fn_: *mut IrqHandlerFn) -> bool;
}
extern "C" {
    pub fn irqHandlerSwap(arg1: u16, fn_: *mut IrqHandlerFn) -> bool;
}
extern "C" {
    pub fn irqEnable(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqDisable(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqEnableFull(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqDisableFull(irqs: u16) -> u16;
}
extern "C" {
    pub fn irqFree(
        f: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
}
impl SerialControl {
    pub const SIO_MODE_RAW: SerialControl = SerialControl::SIO_MODE_SPI_8BIT;
}
impl SerialControl {
    pub const SIO_MODE_JOYBUS: SerialControl = SerialControl::SIO_MODE_SPI_8BIT;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SerialControl {
    SIO_MODE_SPI_8BIT = 0,
    SIO_MODE_SPI_32BIT = 4096,
    SIO_MODE_MULTI = 8192,
    SIO_MODE_UART = 12288,
    SIO_IRQ_ENABLE = 16384,
}
impl RControl {
    pub const R_MODE_SPI_32BIT: RControl = RControl::R_MODE_SPI_8BIT;
}
impl RControl {
    pub const R_MODE_MULTI: RControl = RControl::R_MODE_SPI_8BIT;
}
impl RControl {
    pub const R_MODE_UART: RControl = RControl::R_MODE_SPI_8BIT;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RControl {
    R_MODE_SPI_8BIT = 0,
    R_MODE_RAW = 32768,
    R_MODE_JOYBUS = 49152,
}
extern "C" {
    pub fn sramRead(dst: *mut ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramReadAt(dst: *mut ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramWrite(src: *const ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramWriteAt(src: *const ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramCompare(src: *const ::core::ffi::c_void, len: usize) -> usize;
}
extern "C" {
    pub fn sramCompareAt(src: *const ::core::ffi::c_void, len: usize, off: usize) -> usize;
}
extern "C" {
    pub fn sramClear(len: usize);
}
extern "C" {
    pub fn sramClearAt(len: usize, off: usize);
}
extern "C" {
    pub fn sramRead64(dst: *mut ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramReadAt64(dst: *mut ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramWrite64(src: *const ::core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn sramWriteAt64(src: *const ::core::ffi::c_void, len: usize, off: usize);
}
extern "C" {
    pub fn sramClear64(len: usize);
}
extern "C" {
    pub fn sramClearAt64(len: usize, off: usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TimerControl {
    TIMER_FREQ_16MHZ = 0,
    TIMER_FREQ_262KHZ = 1,
    TIMER_FREQ_64KHZ = 2,
    TIMER_FREQ_16KHZ = 3,
    TIMER_FREQ_CASCADE = 4,
    TIMER_IRQ_ENABLE = 64,
    TIMER_ENABLE = 128,
}
extern "C" {
    pub fn timerSet(num: u32, reload: u16, flags: u16);
}
extern "C" {
    pub fn timerEnable(num: u32);
}
extern "C" {
    pub fn timerDisable(num: u32);
}
extern "C" {
    pub fn timerGetValue(num: u32) -> u16;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LCDDimensions {
    LCD_WIDTH = 240,
    LCD_HEIGHT = 160,
    LCD_SCANLINES = 228,
}
impl DisplayControl {
    pub const VIDEO_OBJ_LAYOUT_2D: DisplayControl = DisplayControl::VIDEO_MODE_REGULAR;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DisplayControl {
    VIDEO_MODE_REGULAR = 0,
    VIDEO_MODE_MIXED = 1,
    VIDEO_MODE_AFFINE = 2,
    VIDEO_MODE_BITMAP = 3,
    VIDEO_MODE_BITMAP_INDEXED = 4,
    VIDEO_MODE_BITMAP_SMALL = 5,
    VIDEO_FRAME_SELECT = 16,
    VIDEO_OBJ_LAYOUT_1D = 64,
    VIDEO_FORCE_BLANK = 128,
    VIDEO_BG0_ENABLE = 256,
    VIDEO_BG1_ENABLE = 512,
    VIDEO_BG2_ENABLE = 1024,
    VIDEO_BG3_ENABLE = 2048,
    VIDEO_OBJ_ENABLE = 4096,
    VIDEO_WIN0_ENABLE = 8192,
    VIDEO_WIN1_ENABLE = 16384,
    VIDEO_OBJ_WIN_ENABLE = 32768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DisplayStatus {
    LCD_IN_VBLANK = 1,
    LCD_IN_HBLANK = 2,
    LCD_VCOUNT_MATCH = 4,
    LCD_VBLANK_IRQ_ENABLE = 8,
    LCD_HBLANK_IRQ_ENABLE = 16,
    LCD_VCOUNT_IRQ_ENABLE = 32,
}
impl VerticalCount {
    pub const VCOUNT_BLANK_START: VerticalCount = VerticalCount::VCOUNT_DRAW_END;
}
impl VerticalCount {
    pub const VCOUNT_BLANK_END: VerticalCount = VerticalCount::VCOUNT_DRAW_START;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VerticalCount {
    VCOUNT_DRAW_START = 0,
    VCOUNT_DRAW_END = 160,
}
impl BackgroundControl {
    pub const BG_TILE_4BPP: BackgroundControl = BackgroundControl::BG_PRIORITY_MAX;
}
impl BackgroundControl {
    pub const BG_SIZE_256X256: BackgroundControl = BackgroundControl::BG_PRIORITY_MAX;
}
impl BackgroundControl {
    pub const BG_AFFINE_SIZE_128X128: BackgroundControl = BackgroundControl::BG_PRIORITY_MAX;
}
impl BackgroundControl {
    pub const BG_AFFINE_SIZE_256X256: BackgroundControl = BackgroundControl::BG_SIZE_512X256;
}
impl BackgroundControl {
    pub const BG_AFFINE_SIZE_512X512: BackgroundControl = BackgroundControl::BG_SIZE_256X512;
}
impl BackgroundControl {
    pub const BG_AFFINE_SIZE_1024X1024: BackgroundControl = BackgroundControl::BG_SIZE_512X512;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BackgroundControl {
    BG_PRIORITY_MIN = 3,
    BG_PRIORITY_MAX = 0,
    BG_MOSAIC_ENABLE = 64,
    BG_TILE_8BPP = 128,
    BG_AFFINE_WRAP = 8192,
    BG_SIZE_512X256 = 16384,
    BG_SIZE_256X512 = 32768,
    BG_SIZE_512X512 = 49152,
}
impl Waitstate {
    pub const WAIT_ROM_N_4: Waitstate = Waitstate::WAIT_SRAM_4;
}
impl Waitstate {
    pub const WAIT_ROM_S_2: Waitstate = Waitstate::WAIT_SRAM_4;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Waitstate {
    WAIT_SRAM_4 = 0,
    WAIT_SRAM_3 = 1,
    WAIT_SRAM_2 = 2,
    WAIT_SRAM_8 = 3,
    WAIT_ROM_N_3 = 4,
    WAIT_ROM_N_2 = 8,
    WAIT_ROM_N_8 = 12,
    WAIT_ROM_S_1 = 16,
    WAIT_PREFETCH_ENABLE = 16384,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BgAffineSrcData {
    pub src_center_x: i32,
    pub src_center_y: i32,
    pub disp_center_x: i16,
    pub disp_center_y: i16,
    pub ratio_x: i16,
    pub ratio_y: i16,
    pub theta: u16,
}
#[test]
fn bindgen_test_layout_BgAffineSrcData() {
    const UNINIT: ::core::mem::MaybeUninit<BgAffineSrcData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BgAffineSrcData>(),
        20usize,
        concat!("Size of: ", stringify!(BgAffineSrcData))
    );
    assert_eq!(
        ::core::mem::align_of::<BgAffineSrcData>(),
        4usize,
        concat!("Alignment of ", stringify!(BgAffineSrcData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_center_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(src_center_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_center_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(src_center_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disp_center_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(disp_center_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disp_center_y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(disp_center_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(ratio_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(ratio_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).theta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineSrcData),
            "::",
            stringify!(theta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BgAffineDstData {
    pub h_diff_x: i16,
    pub v_diff_x: i16,
    pub h_diff_y: i16,
    pub v_diff_y: i16,
    pub start_x: i32,
    pub start_y: i32,
}
#[test]
fn bindgen_test_layout_BgAffineDstData() {
    const UNINIT: ::core::mem::MaybeUninit<BgAffineDstData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BgAffineDstData>(),
        16usize,
        concat!("Size of: ", stringify!(BgAffineDstData))
    );
    assert_eq!(
        ::core::mem::align_of::<BgAffineDstData>(),
        4usize,
        concat!("Alignment of ", stringify!(BgAffineDstData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(h_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_x) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(v_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(h_diff_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(v_diff_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BgAffineDstData),
            "::",
            stringify!(start_y)
        )
    );
}
extern "C" {
    pub fn biosBgAffineSet(src: *const BgAffineSrcData, dst: *mut BgAffineDstData, num: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjAffineSrcData {
    pub ratio_x: i16,
    pub ratio_y: i16,
    pub theta: u16,
    pub pad: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_ObjAffineSrcData() {
    const UNINIT: ::core::mem::MaybeUninit<ObjAffineSrcData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ObjAffineSrcData>(),
        8usize,
        concat!("Size of: ", stringify!(ObjAffineSrcData))
    );
    assert_eq!(
        ::core::mem::align_of::<ObjAffineSrcData>(),
        2usize,
        concat!("Alignment of ", stringify!(ObjAffineSrcData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(ratio_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ratio_y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(ratio_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).theta) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(theta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineSrcData),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjAffineDstData {
    pub h_diff_x: i16,
    pub v_diff_x: i16,
    pub h_diff_y: i16,
    pub v_diff_y: i16,
}
#[test]
fn bindgen_test_layout_ObjAffineDstData() {
    const UNINIT: ::core::mem::MaybeUninit<ObjAffineDstData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ObjAffineDstData>(),
        8usize,
        concat!("Size of: ", stringify!(ObjAffineDstData))
    );
    assert_eq!(
        ::core::mem::align_of::<ObjAffineDstData>(),
        2usize,
        concat!("Alignment of ", stringify!(ObjAffineDstData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(h_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_x) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(v_diff_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_diff_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(h_diff_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_diff_y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjAffineDstData),
            "::",
            stringify!(v_diff_y)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ObjAffineSetOffset {
    OAS_OFFSET_DSTDATA = 2,
    OAS_OFFSET_OAM = 8,
}
extern "C" {
    pub fn biosObjAffineSet(
        src: *const ObjAffineSrcData,
        dst: *mut ::core::ffi::c_void,
        num: u32,
        offset: u32,
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct BitUnPackParam {
    pub src_length: u16,
    pub src_width: u8,
    pub dst_width: u8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_BitUnPackParam() {
    const UNINIT: ::core::mem::MaybeUninit<BitUnPackParam> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BitUnPackParam>(),
        8usize,
        concat!("Size of: ", stringify!(BitUnPackParam))
    );
    assert_eq!(
        ::core::mem::align_of::<BitUnPackParam>(),
        4usize,
        concat!("Alignment of ", stringify!(BitUnPackParam))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitUnPackParam),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_width) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BitUnPackParam),
            "::",
            stringify!(src_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_width) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BitUnPackParam),
            "::",
            stringify!(dst_width)
        )
    );
}
impl BitUnPackParam {
    #[inline]
    pub fn offset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_zeroes(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_zeroes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32, keep_zeroes: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let keep_zeroes: u32 = unsafe { ::core::mem::transmute(keep_zeroes) };
            keep_zeroes as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn biosBitUnPack(
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        param: *const BitUnPackParam,
    );
}
extern "C" {
    pub fn biosLZ77UnCompWram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosLZ77UnCompVram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosHuffUnComp(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosRLUnCompWram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosRLUnCompVram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosDiff8bitUnFilterWram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosDiff8bitUnFilterVram(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn biosDiff16bitUnFilter(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Div {
    pub quot: i32,
    pub rem: i32,
}
#[test]
fn bindgen_test_layout_Div() {
    const UNINIT: ::core::mem::MaybeUninit<Div> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Div>(),
        8usize,
        concat!("Size of: ", stringify!(Div))
    );
    assert_eq!(
        ::core::mem::align_of::<Div>(),
        4usize,
        concat!("Alignment of ", stringify!(Div))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Div), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Div), "::", stringify!(rem))
    );
}
extern "C" {
    pub fn biosDiv(numerator: i32, denominator: i32) -> i32;
}
extern "C" {
    pub fn biosDivMod(numerator: i32, denominator: i32) -> Div;
}
extern "C" {
    pub fn biosSqrt(x: u32) -> u16;
}
extern "C" {
    pub fn biosArcTan(tan: i16) -> i16;
}
extern "C" {
    pub fn biosArcTan2(x: i16, y: i16) -> u16;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CpuSetFlags {
    CS_SRC_FIXED = 16777216,
    CS_32BIT = 67108864,
    CS_16BIT = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CpuFastSetFlags {
    CFS_SRC_FIXED = 16777216,
}
extern "C" {
    pub fn biosCpuSet(src: *const ::core::ffi::c_void, dst: *mut ::core::ffi::c_void, ctrl: u32);
}
extern "C" {
    pub fn biosCpuFastSet(
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        ctrl: u32,
    );
}
extern "C" {
    pub fn biosSoftReset() -> !;
}
extern "C" {
    pub fn biosHardReset() -> !;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SoftResetExFlags {
    SRE_FROM_ROM = 0,
    SRE_FROM_RAM = 1,
}
extern "C" {
    pub fn biosSoftResetEx(reset_flags: u8, from_ewram: bool) -> !;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RegisterRamResetFlags {
    RRR_EWRAM = 1,
    RRR_IWRAM = 2,
    RRR_PALETTE = 4,
    RRR_VRAM = 8,
    RRR_OAM = 16,
    RRR_SIO = 32,
    RRR_SOUND = 64,
    RRR_REGISTERS = 128,
    RRR_EVERYTHING = 255,
}
extern "C" {
    pub fn biosRegisterRamReset(reset_flags: u8);
}
extern "C" {
    pub fn biosSoundDriverMain();
}
extern "C" {
    pub fn biosSoundDriverVSync();
}
extern "C" {
    pub fn biosSoundChannelClear();
}
extern "C" {
    pub fn biosSoundDriverVSyncOff();
}
extern "C" {
    pub fn biosSoundDriverVSyncOn();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BiosChecksum {
    BIOS_CHECKSUM_GBA = 3131971711,
    BIOS_CHECKSUM_NDS = 3131971712,
}
extern "C" {
    pub fn biosBiosChecksum() -> u32;
}
extern "C" {
    pub fn biosHalt();
}
extern "C" {
    pub fn biosStop();
}
extern "C" {
    pub fn biosIntrWait(wait_next: bool, intr_flags: u16);
}
extern "C" {
    pub fn biosVBlankIntrWait();
}
impl SerialControlMultiplayer {
    pub const MULTI_BUSY: SerialControlMultiplayer = SerialControlMultiplayer::MULTI_START;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SerialControlMultiplayer {
    MULTI_BAUD_9600 = 0,
    MULTI_BAUD_38400 = 1,
    MULTI_BAUD_57600 = 2,
    MULTI_BAUD_115200 = 3,
    MULTI_CLIENT_FLAG = 4,
    MULTI_READY_FLAG = 8,
    MULTI_ERROR_FLAG = 64,
    MULTI_START = 128,
}
impl RControlRaw {
    pub const RAW_SD_DIR_IN: RControlRaw = RControlRaw::RAW_SC_DIR_IN;
}
impl RControlRaw {
    pub const RAW_SI_DIR_IN: RControlRaw = RControlRaw::RAW_SC_DIR_IN;
}
impl RControlRaw {
    pub const RAW_SO_DIR_IN: RControlRaw = RControlRaw::RAW_SC_DIR_IN;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RControlRaw {
    RAW_SC_DIR_OUT = 16,
    RAW_SC_DIR_IN = 0,
    RAW_SD_DIR_OUT = 32,
    RAW_SI_DIR_OUT = 64,
    RAW_SO_DIR_OUT = 128,
    RAW_SI_IRQ_ENABLE = 256,
}
impl SerialControlSPI {
    pub const SPI_SO_LOW: SerialControlSPI = SerialControlSPI::SPI_CLOCK_EXTERNAL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SerialControlSPI {
    SPI_CLOCK_EXTERNAL = 0,
    SPI_CLOCK_256KHZ = 1,
    SPI_CLOCK_2MHZ = 3,
    SPI_SI_STATE = 4,
    SPI_SO_HIGH = 8,
    SPI_START = 128,
}
impl SerialControlUART {
    pub const UART_PARITY_EVEN: SerialControlUART = SerialControlUART::UART_BAUD_9600;
}
impl SerialControlUART {
    pub const UART_7BIT: SerialControlUART = SerialControlUART::UART_BAUD_9600;
}
impl SerialControlUART {
    pub const UART_FIFO_ENABLE: SerialControlUART = SerialControlUART::UART_8BIT;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SerialControlUART {
    UART_BAUD_9600 = 0,
    UART_BAUD_38400 = 1,
    UART_BAUD_57600 = 2,
    UART_BAUD_115200 = 3,
    UART_CTS_ENABLE = 4,
    UART_PARITY_ODD = 8,
    UART_SEND_FULL = 16,
    UART_RECEIVE_EMPTY = 32,
    UART_ERROR = 64,
    UART_8BIT = 256,
    UART_PARITY_ENABLE = 512,
    UART_SEND_ENABLE = 1024,
    UART_RECEIVE_ENABLE = 2048,
}
pub type Color = u16;
pub type Palette = [Color; 256usize];
pub type PaletteBank = [Color; 16usize];
pub type MapEntry = u16;
pub type AffineMapEntry = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Matrix {
    pub hdx: i16,
    pub vdx: i16,
    pub hdy: i16,
    pub vdy: i16,
}
#[test]
fn bindgen_test_layout_Matrix() {
    const UNINIT: ::core::mem::MaybeUninit<Matrix> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Matrix>(),
        8usize,
        concat!("Size of: ", stringify!(Matrix))
    );
    assert_eq!(
        ::core::mem::align_of::<Matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(Matrix))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(hdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vdx) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(vdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(hdy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vdy) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(vdy)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Object {
    pub attr0: u16,
    pub attr1: u16,
    pub attr2: u16,
    pub _reserved: u16,
}
#[test]
fn bindgen_test_layout_Object() {
    const UNINIT: ::core::mem::MaybeUninit<Object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Object>(),
        8usize,
        concat!("Size of: ", stringify!(Object))
    );
    assert_eq!(
        ::core::mem::align_of::<Object>(),
        4usize,
        concat!("Alignment of ", stringify!(Object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(attr0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(attr1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(attr2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(_reserved)
        )
    );
}
pub type Mode3Frame = [[u16; 240usize]; 160usize];
pub type Mode4Frame = [[u16; 120usize]; 160usize];
pub type Mode5Frame = [[u16; 160usize]; 128usize];
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Tile {
    TILE_FLIP_H = 1024,
    TILE_FLIP_V = 2048,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BlendControl {
    BLEND_TARGET_BG0 = 1,
    BLEND_TARGET_BG1 = 2,
    BLEND_TARGET_BG2 = 4,
    BLEND_TARGET_BG3 = 8,
    BLEND_TARGET_OBJ = 16,
    BLEND_TARGET_BD = 32,
    BLEND_MODE_NONE = 0,
    BLEND_MODE_ALPHA = 64,
    BLEND_MODE_WHITE = 128,
    BLEND_MODE_BLACK = 192,
    BLEND_TARGET2_BG0 = 256,
    BLEND_TARGET2_BG1 = 512,
    BLEND_TARGET2_BG2 = 1024,
    BLEND_TARGET2_BG3 = 2048,
    BLEND_TARGET2_OBJ = 4096,
    BLEND_TARGET2_BD = 8192,
}
impl ColorConstants {
    pub const COLOR_GRAY_0: ColorConstants = ColorConstants::COLOR_BLACK;
}
impl ColorConstants {
    pub const COLOR_GRAY_100: ColorConstants = ColorConstants::COLOR_WHITE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ColorConstants {
    COLOR_RED = 31,
    COLOR_RED_ORANGE = 287,
    COLOR_ORANGE = 511,
    COLOR_ORANGE_YELLOW = 767,
    COLOR_YELLOW = 1023,
    COLOR_YELLOW_LIME = 1015,
    COLOR_LIME = 1007,
    COLOR_LIME_GREEN = 1000,
    COLOR_GREEN = 992,
    COLOR_GREEN_MINT = 9184,
    COLOR_MINT = 16352,
    COLOR_MINT_CYAN = 24544,
    COLOR_CYAN = 32736,
    COLOR_CYAN_SKYBLUE = 32480,
    COLOR_SKYBLUE = 32224,
    COLOR_SKYBLUE_BLUE = 32000,
    COLOR_BLUE = 31744,
    COLOR_BLUE_PURPLE = 31752,
    COLOR_PURPLE = 31759,
    COLOR_PURPLE_MAGENTA = 31767,
    COLOR_MAGENTA = 31775,
    COLOR_MAGENTA_PINK = 23583,
    COLOR_PINK = 15391,
    COLOR_PINK_RED = 8223,
    COLOR_BLACK = 0,
    COLOR_WHITE = 32767,
    COLOR_GRAY_5 = 2114,
    COLOR_GRAY_10 = 3171,
    COLOR_GRAY_15 = 5285,
    COLOR_GRAY_20 = 6342,
    COLOR_GRAY_25 = 8456,
    COLOR_GRAY_30 = 9513,
    COLOR_GRAY_35 = 11627,
    COLOR_GRAY_40 = 12684,
    COLOR_GRAY_45 = 14798,
    COLOR_GRAY_50 = 15855,
    COLOR_GRAY_55 = 17969,
    COLOR_GRAY_60 = 20083,
    COLOR_GRAY_65 = 21140,
    COLOR_GRAY_70 = 23254,
    COLOR_GRAY_75 = 24311,
    COLOR_GRAY_80 = 26425,
    COLOR_GRAY_85 = 27482,
    COLOR_GRAY_90 = 29596,
    COLOR_GRAY_95 = 30653,
}
extern "C" {
    pub fn oamWriteObjects(oam_index: usize, objs: *mut Object, n_objs: usize) -> usize;
}
extern "C" {
    pub fn oamWriteObjectsUnchecked(oam_index: usize, objs: *mut Object, n_objs: usize) -> usize;
}
extern "C" {
    pub fn oamWriteMatrices(oam_index: usize, mats: *mut Matrix, n_mats: usize) -> usize;
}
extern "C" {
    pub fn oamWriteMatricesUnchecked(oam_index: usize, mats: *mut Matrix, n_mats: usize) -> usize;
}
impl ObjectAttribute0 {
    pub const OBJ_TYPE_REGULAR: ObjectAttribute0 = ObjectAttribute0::OBJ_MODE_REGULAR;
}
impl ObjectAttribute0 {
    pub const OBJ_TILE_4BPP: ObjectAttribute0 = ObjectAttribute0::OBJ_MODE_REGULAR;
}
impl ObjectAttribute0 {
    pub const OBJ_SHAPE_SQUARE: ObjectAttribute0 = ObjectAttribute0::OBJ_MODE_REGULAR;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ObjectAttribute0 {
    OBJ_MODE_REGULAR = 0,
    OBJ_MODE_AFFINE = 256,
    OBJ_MODE_HIDDEN = 512,
    OBJ_MODE_DOUBLE = 768,
    OBJ_TYPE_BLEND = 1024,
    OBJ_TYPE_WINDOW = 2048,
    OBJ_MOSAIC_ENABLE = 4096,
    OBJ_TILE_8BPP = 8192,
    OBJ_SHAPE_WIDE = 16384,
    OBJ_SHAPE_TALL = 32768,
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_16X8: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_8X8;
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_32X8: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_16X16;
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_32X16: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_32X32;
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_64X32: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_64X64;
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_8X16: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_8X8;
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_8X32: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_16X16;
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_16X32: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_32X32;
}
impl ObjectAttribute1 {
    pub const OBJ_SIZE_32X64: ObjectAttribute1 = ObjectAttribute1::OBJ_SIZE_64X64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ObjectAttribute1 {
    OBJ_FLIP_H = 4096,
    OBJ_FLIP_V = 8192,
    OBJ_SIZE_8X8 = 0,
    OBJ_SIZE_16X16 = 16384,
    OBJ_SIZE_32X32 = 32768,
    OBJ_SIZE_64X64 = 49152,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ObjectAttribute2 {
    OBJ_PRIORITY_MIN = 3072,
    OBJ_PROIRITY_MAX = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WindowControl {
    WINDOW_BG0_ENABLE = 1,
    WINDOW_BG1_ENABLE = 2,
    WINDOW_BG2_ENABLE = 4,
    WINDOW_BG3_ENABLE = 8,
    WINDOW_OBJ_ENABLE = 16,
    WINDOW_BLEND_ENABLE = 32,
}
pub type AssertHandlerFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: u32,
    ),
>;
extern "C" {
    pub fn assertSetHandler(handler: AssertHandlerFn) -> AssertHandlerFn;
}
extern "C" {
    pub fn assertGetHandler() -> AssertHandlerFn;
}
extern "C" {
    pub fn assertRaise(
        message: *const ::core::ffi::c_char,
        function: *const ::core::ffi::c_char,
        file: *const ::core::ffi::c_char,
        line: u32,
    ) -> !;
}
extern "C" {
    pub fn bitCTZ32(value: u32) -> u32;
}
extern "C" {
    pub fn bitCTZ16(value: u16) -> u32;
}
extern "C" {
    pub fn bitCTZ8(value: u8) -> u32;
}
extern "C" {
    pub fn bitCLZ32(value: u32) -> u32;
}
extern "C" {
    pub fn bitCLZ16(value: u16) -> u32;
}
extern "C" {
    pub fn bitCLZ8(value: u8) -> u32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DebugException {
    EXCEPTION_UNDEFINED_INSTRUCTION = 0,
    EXCEPTION_PREFETCH_ABORT = 1,
    EXCEPTION_DATA_ABORT = 2,
    EXCEPTION_IRQ = 3,
    EXCEPTION_FIQ = 4,
}
extern "C" {
    pub fn dbgRaiseException(exception: u32) -> bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LogLevel {
    LOG_OFF = 0,
    LOG_FATAL = 1,
    LOG_ERROR = 2,
    LOG_WARN = 3,
    LOG_INFO = 4,
    LOG_DEBUG = 5,
    LOG_TRACE = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LogInterface {
    LOGIF_NONE = 0,
    LOGIF_MGBA = 1,
    LOGIF_NOCASH = 2,
    LOGIF_VBA = 3,
    LOGIF_CUSTOM = 255,
}
pub type LogCustomOutputFunction =
    ::core::option::Option<unsafe extern "C" fn(arg1: u8, arg2: *const ::core::ffi::c_char)>;
extern "C" {
    pub fn logInit() -> u8;
}
extern "C" {
    pub fn logInitInterface(interface: u8) -> bool;
}
extern "C" {
    pub fn logInitCustom(f: LogCustomOutputFunction);
}
extern "C" {
    pub fn logGetInterface() -> u8;
}
extern "C" {
    pub fn logGetInterfaceName() -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn logSetMaxLevel(level: u8);
}
extern "C" {
    pub fn logGetMaxLevel() -> u8;
}
extern "C" {
    pub fn logOutput(level: u8, message: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn profileRun(
        function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        data: *mut ::core::ffi::c_void,
    ) -> u32;
}
extern "C" {
    pub fn randSetSeed(seed: u32);
}
extern "C" {
    pub fn randNext() -> u32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SIMDMask {
    SIMD_MASK_4X8 = 2155905152,
    SIMD_MASK_2X16 = 2147516416,
    SIMD_MASK_2XRGB = 3255878160,
}
extern "C" {
    pub fn simdAdd(
        mask: u32,
        lhs: *mut ::core::ffi::c_void,
        rhs: *const ::core::ffi::c_void,
        len: usize,
    );
}
extern "C" {
    pub fn simdSub(
        mask: u32,
        lhs: *mut ::core::ffi::c_void,
        rhs: *const ::core::ffi::c_void,
        len: usize,
    );
}
